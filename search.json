[{"title":"course_comprehensive_ic_design","url":"/2024/05/09/course-comprehensive-ic-design/","content":"\n# 专业综合实验过程记录\n\n## 实验1\n\n### 加法器\n\n#### 一位全加器\n\n对移位全加器而言，不同的写法有不同的综合结果。\n\n```verilog\nmodule adder(\n    input i_x,\n    input i_y,\n    input i_cin,\n    output o_sum,\n    output o_cout\n);\n    wire w_p, w_g;\n\n    assign w_p = i_x ^ i_y;\n    assign w_g = i_x & i_y;\n\n    assign o_sum = w_p ^ i_cin;\n    assign o_cout = (w_p & i_cin) | w_g;\n\nendmodule\n```\n\nRTL分析：\n\n![image-20240509170552029](https://s2.loli.net/2024/05/09/Zy6N7ITeQPqMVti.png)\n\n综合结果如下。可以看到FPGA内部通过查找表实现组合逻辑电路。\n\n![image-20240509170736387](https://s2.loli.net/2024/05/09/pnsWNGCzhS527HV.png)\n\n如果直接写加法：\n\n```verilog\nmodule adder(\n    input i_x,\n    input i_y,\n    input i_cin,\n    output o_sum,\n    output o_cout\n);\n    assign {o_cout, o_sum} = i_x + i_y + i_cin;\n\nendmodule\n```\n\nRTL分析：\n\n![image-20240509171015390](https://s2.loli.net/2024/05/09/fLGieRFmoXrlqjs.png)\n\n综合电路不变。vivado都会使用查找表（LUT）实现电路。\n\n#### 超前进位加法器\n\n```verilog\n/*\n * File Created: Thursday, 9th May 2024 16:38:42\n * Author: Yun Zhang\n *\n * Last Modified: Thursday, 9th May 2024 22:02:16\n *\n * Function: One-bit full adder\n */\n\nmodule m_adder(\n        input i_x,\n        input i_y,\n        input i_cin,\n        output o_sum,\n        output o_p,\n        output o_g\n    );\n\n    wire w_p, w_g;\n\n    assign o_p = w_p;\n    assign o_g = w_g;\n\n    assign w_p = i_x ^ i_y;\n    assign w_g = i_x & i_y;\n\n    assign o_sum = w_p ^ i_cin;\n    assign o_cout = (w_p & i_cin) | w_g;\n\nendmodule\n\n```\n\n```verilog\n/*\n * File Created: Thursday, 9th May 2024 18:51:45\n * Author: Yun Zhang\n *\n * Last Modified: Thursday, 9th May 2024 22:02:12\n *\n * Function: carry lookahead adder with parameter NUM_BITS\n */\n\nmodule m_cla # (\n    parameter NUM_BITS = 4\n) (\n    input i_cin,\n    input [NUM_BITS - 1:0] i_p,\n    input [NUM_BITS - 1:0] i_g,\n    output [NUM_BITS - 1:0] o_c\n);\n    wire [NUM_BITS - 1:0] w_c;\n\n    assign o_c = w_c;\n\n    assign w_c[0] = (i_p[0] & i_cin) | i_g[0];\n\n    genvar i;\n    generate\n        for (i = 1; i < NUM_BITS; i = i + 1) begin\n            assign w_c[i] = (i_p[i] & w_c[i - 1]) | i_g[i];\n        end\n    endgenerate\n\nendmodule\n\n```\n\n```verilog\n/*\n * File Created: Thursday, 9th May 2024 18:27:09\n * Author: Yun Zhang\n *\n * Last Modified: Friday, 10th May 2024 00:01:28\n *\n * Function: top module for carry lookahead adder with parameter NUM_BITS\n */\n\nmodule m_adder_fast_top # (\n        parameter NUM_BITS = 4\n    ) (\n        input [NUM_BITS - 1:0] i_a,\n        input [NUM_BITS - 1:0] i_b,\n        input i_cin,\n        output [NUM_BITS - 1:0] o_sum,\n        output o_cout\n    );\n\n    wire [NUM_BITS - 1:0] w_p, w_g;\n    wire [NUM_BITS - 1:0] w_c;\n\n    assign o_cout = w_c[NUM_BITS - 1];\n\n    genvar i;\n    generate\n        for (i = 0; i < NUM_BITS; i = i + 1) begin\n            if (i == 0)\n                m_adder adder_inst(\n                            .i_x    (i_a[0]     ),\n                            .i_y    (i_b[0]     ),\n                            .i_cin  (i_cin      ),\n                            .o_sum  (o_sum[0]   ),\n                            .o_p    (w_p[0]     ),\n                            .o_g    (w_g[0]     )\n                        );\n            else\n                m_adder adder_inst(\n                            .i_x    (i_a[i]     ),\n                            .i_y    (i_b[i]     ),\n                            .i_cin  (w_c[i-1]   ),\n                            .o_sum  (o_sum[i]   ),\n                            .o_p    (w_p[i]     ),\n                            .o_g    (w_g[i]     )\n                        );\n        end\n    endgenerate\n\n    m_cla #(\n              .NUM_BITS(NUM_BITS)\n          )cla_inst(\n              .i_cin  (i_cin      ),\n              .i_p    (w_p        ),\n              .i_g    (w_g        ),\n              .o_c    (w_c        )\n          );\n\nendmodule\n\n```\n\ntb文件\n\n```verilog\n/*\n * File Created: Thursday, 9th May 2024 20:06:46\n * Anthor: Yun Zhang\n *\n * Last Modified: Thursday, 9th May 2024 23:57:02\n *\n * Function: test bench for carry lookahead adder\n */\n\n`timescale 1ns/1ns\nmodule m_adder_fast_top_tb;\n\n    // Parameters\n    localparam  NUM_BITS = 4;\n\n    //Ports\n    reg [NUM_BITS - 1:0] i_a;\n    reg [NUM_BITS - 1:0] i_b;\n    reg  i_cin;\n    wire [NUM_BITS - 1:0] o_sum;\n    wire  o_cout;\n\n    m_adder_fast_top # (\n                         .NUM_BITS(NUM_BITS)\n                     )\n                     m_adder_fast_top_inst (\n                         .i_a(i_a),\n                         .i_b(i_b),\n                         .i_cin(i_cin),\n                         .o_sum(o_sum),\n                         .o_cout(o_cout)\n                     );\n\n    always begin\n        #10 i_a = {$random} % 16;\n        i_b = {$random} % 16;\n    end\n    initial begin\n        i_a = 4'b0001;\n        i_b = 4'b0010;\n        i_cin = 1'b0;\n    end\n\nendmodule\n\n```\n\nRTL电路\n\n![image-20240510000233924](https://s2.loli.net/2024/05/10/xJYA3l9MG7fQmtS.png)\n\n仿真结果\n\n![image-20240510000357125](https://s2.loli.net/2024/05/10/q17Mhpcr6Hgfu9O.png)\n\n### 乘法器\n\n#### 使用参数化设计的带符号数补码乘法器\n\n```verilog\n/*\n * File Created: Thursday, 9th May 2024 21:58:06\n * Author: Yun Zhang\n *\n * Last Modified: Thursday, 9th May 2024 22:45:51\n *\n * Function: multiplier with parameter NUM_BITS\n */\n\nmodule m_mul #(\n    parameter NUM_BITS = 4\n) (\n    input [NUM_BITS - 1:0] i_x,\n    input [NUM_BITS - 1:0] i_y,\n    output [NUM_BITS * 2 - 1:0] o_z\n);\n\n    wire [NUM_BITS - 1:0] w_xy [NUM_BITS - 1:0];\n    wire [NUM_BITS * 2 - 1:0] w_temp [NUM_BITS - 1:0];\n\n    reg [NUM_BITS * 2 - 1:0] r_z;\n\n    assign o_z = r_z;\n\n    genvar i;\n    generate\n        for (i = 0; i < NUM_BITS; i = i + 1) begin\n            assign w_xy[i] = i_x[i] ? i_y : {NUM_BITS{1'b0}};\n\n            if (i == 0)\n                assign w_temp[i] = {{(NUM_BITS-1){1'b0}}, 1'b1, ~w_xy[i][NUM_BITS-1], w_xy[i][NUM_BITS-2:0]};\n            else if (i == NUM_BITS - 1)\n                assign w_temp[i] = {{(NUM_BITS-1){1'b0}}, 1'b1, w_xy[i][NUM_BITS-1], ~w_xy[i][NUM_BITS-2:0]};\n            else\n                assign w_temp[i] = {{(NUM_BITS){1'b0}}, ~w_xy[i][NUM_BITS-1], w_xy[i][NUM_BITS-2:0]};\n        end\n    endgenerate\n\n    integer j;\n    always @(*) begin\n        r_z = 0;\n        for (j = 0; j < NUM_BITS; j = j + 1) begin\n            r_z = r_z + (w_temp[j] << j);\n        end\n    end\n\nendmodule\n\n\n```\n\ntb文件\n\n```verilog\n/*\n * File Created: Thursday, 9th May 2024 21:58:06\n * Author: Yun Zhang\n *\n * Last Modified: Thursday, 9th May 2024 22:48:48\n *\n * Function: testbench for multiplier\n */\n\n\nmodule m_mul_tb;\n\n    // Parameters\n    localparam  NUM_BITS = 4;\n\n    // Ports\n    reg [NUM_BITS - 1:0] i_x;\n    reg [NUM_BITS - 1:0] i_y;\n    wire [NUM_BITS * 2 - 1:0] o_z;\n\n    m_mul # (\n              .NUM_BITS(NUM_BITS)\n          )\n          m_mul_inst (\n              .i_x(i_x),\n              .i_y(i_y),\n              .o_z(o_z)\n          );\n\n    always begin\n        #10\n        i_x = $random % 8;\n        i_y = $random % 8;\n    end\n    initial begin\n        i_x = 4'b0001;\n        i_y = 4'b0010;\n    end\n\nendmodule\n\n```\n\nRTL电路\n\n![image-20240509225123110](https://s2.loli.net/2024/05/09/6Gw2xURfdyXpImv.png)\n\n仿真结果\n\n![image-20240509225154373](https://s2.loli.net/2024/05/09/Az7yD5P2VCIptZc.png)\n\n### 八选一数据选择器\n\n```verilog\n/*\n * File Created: Friday, 10th May 2024 10:15:47\n * Author: Yun Zhang\n *\n * Last Modified: Friday, 10th May 2024 11:22:56\n *\n * Function: 8-1 multiplexer\n */\n\nmodule multiplexer_8 #(\n    parameter DATA_BIT_WIDTH = 8\n) (\n    input i_cs_n,       // chip select (active low)\n\n    input [3:0] i_sel,\n    input [DATA_BIT_WIDTH-1:0] i_data_0,\n    input [DATA_BIT_WIDTH-1:0] i_data_1,\n    input [DATA_BIT_WIDTH-1:0] i_data_2,\n    input [DATA_BIT_WIDTH-1:0] i_data_3,\n    input [DATA_BIT_WIDTH-1:0] i_data_4,\n    input [DATA_BIT_WIDTH-1:0] i_data_5,\n    input [DATA_BIT_WIDTH-1:0] i_data_6,\n    input [DATA_BIT_WIDTH-1:0] i_data_7,\n\n    output reg [DATA_BIT_WIDTH-1:0] o_data\n);\n\n    always @(*) begin\n        if (!i_cs_n)\n            case (i_sel)\n                3'b000: o_data = i_data_0;\n                3'b001: o_data = i_data_1;\n                3'b010: o_data = i_data_2;\n                3'b011: o_data = i_data_3;\n                3'b100: o_data = i_data_4;\n                3'b101: o_data = i_data_5;\n                3'b110: o_data = i_data_6;\n                3'b111: o_data = i_data_7;\n                default: o_data = {DATA_BIT_WIDTH{1'bz}};\n            endcase\n        else\n            o_data = {DATA_BIT_WIDTH{1'bz}};\n    end\n\nendmodule\n```\n\n```verilog\n/*\n * File Created: Friday, 10th May 2024 11:18:53\n * Author: Yun Zhang\n *\n * Last Modified: Friday, 10th May 2024 11:27:06\n *\n * Function: Testbench for 8-1 multiplexer\n */\n\n`timescale 1ns/1ns\nmodule multiplexer_8_tb;\n\n    // Parameters\n    localparam  DATA_BIT_WIDTH = 8;\n\n    // Ports\n    reg  i_cs_n;\n    reg [3:0] i_sel;\n    reg [DATA_BIT_WIDTH-1:0] i_data_0;\n    reg [DATA_BIT_WIDTH-1:0] i_data_1;\n    reg [DATA_BIT_WIDTH-1:0] i_data_2;\n    reg [DATA_BIT_WIDTH-1:0] i_data_3;\n    reg [DATA_BIT_WIDTH-1:0] i_data_4;\n    reg [DATA_BIT_WIDTH-1:0] i_data_5;\n    reg [DATA_BIT_WIDTH-1:0] i_data_6;\n    reg [DATA_BIT_WIDTH-1:0] i_data_7;\n    wire [DATA_BIT_WIDTH-1:0] o_data;\n\n    multiplexer_8 # (\n                      .DATA_BIT_WIDTH(DATA_BIT_WIDTH)\n                  )\n                  multiplexer_8_inst (\n                      .i_cs_n(i_cs_n),\n                      .i_sel(i_sel),\n                      .i_data_0(i_data_0),\n                      .i_data_1(i_data_1),\n                      .i_data_2(i_data_2),\n                      .i_data_3(i_data_3),\n                      .i_data_4(i_data_4),\n                      .i_data_5(i_data_5),\n                      .i_data_6(i_data_6),\n                      .i_data_7(i_data_7),\n                      .o_data(o_data)\n                  );\n\n    initial begin\n        i_cs_n = 1'b1;\n        i_data_0 = 8'd0;\n        i_data_1 = 8'd1;\n        i_data_2 = 8'd2;\n        i_data_3 = 8'd3;\n        i_data_4 = 8'd4;\n        i_data_5 = 8'd5;\n        i_data_6 = 8'd6;\n        i_data_7 = 8'd7;\n\n        #20 i_cs_n = 1'b0;\n    end\n\n    always #({$random} % 10) i_sel = {$random} % 8;\n\nendmodule\n\n```\n\n![image-20240510113224359](https://s2.loli.net/2024/05/10/2hsyzGLbmMFWaCd.png)\n\n![image-20240510112739108](https://s2.loli.net/2024/05/10/NSg8GvqpPMKQUoz.png)\n"},{"title":"六级复习","url":"/2024/05/06/English-words/","content":"\n# 词汇背记汇总\n\n## 5-4\n\n|    词汇     |                        短语/搭配/例句                        |      释义      |\n| :---------: | :----------------------------------------------------------: | :------------: |\n|    apart    |         10 miles apart, ten months apart, apart from         |                |\n|   prompt    |                  prompt starting doing sth.                  |                |\n|  regarding  |        I'm writing regarding ..., regarding this case        |      关于      |\n| concerning  |                an issue concerning the future                |      关于      |\n|   sustain   |                                                              |                |\n|  contrary   | contrary to a popular belief, a contrary opinion, <br />be contrary of sth, on the contrary |                |\n|   suppose   |                       be suppose to do                       |                |\n|    yield    |            yield the best rice of China, yield to            |   产出/屈服    |\n|  digestive  |                       digestive system                       |                |\n| circulation |                      blood circulation                       |                |\n|             | **mistaking ... for ...**,<br />mistaking the symptoms of illness for stress. | 错把...当作... |\n|  prescribe  |              Prescribe some medication for him.              |                |\n|  promising  |                 It is remarkably promising.                  | 拥有非凡的前景 |\n|   fatigue   |                         feel fatigue                         |      劳累      |\n|             |                                                              |                |\n\n听力：\n\n- 听前：提前读题（纸是半透明的），猜测（题目大意和内容）+ 过读音\n- 听中：勾画听到的内容（没听到的不勾画），对应程度高的正确率高\n- 听后：不听题目，直接选，并且立即开始读下一题\n\n瑞斯拜听力第一讲：\n\nThese is no indication of any digestive issue.\n\nindication 指标，一般指不好的指标。\n\nwhy do I feel so poorly all the time.\n\n==**两个选项的某两个词同时在一句话内出现，则说明是干扰项，都不选。**==\n\nWhat you have described is a common sentiment. Many people who suffered from stress fail to recognize it.\n\n**I'm going to** prescribe some special sleeping pills for you. ... Your stamnos\n\nI'm a restaurant manager. This industry is very competitive.\n\n## 5-5\n\n|        词汇        |                        搭配/短语/例句                        |   释义    |\n| :----------------: | :----------------------------------------------------------: | :-------: |\n|        ease        |                        with **ease**                         |           |\n|      restore       |                      **restore** order                       | 恢复/修复 |\n| gossip, recreation |   **Gossip**. It's just a harmless form of **recreation**.   |           |\n|     incidence      |             a high **incidence** of **suicide**              |           |\n|      incident      |                                                              | 事件/冲突 |\n|      paradox       |       - Never say \"never\".<br />- That's **paradox**.        |           |\n|       forum        |  the World Economic **Forum** is a not-profit-organization.  |           |\n|     devastate      |             be **devastated** by a **hurricane**             |           |\n|     aspiration     |                    realize **aspiration**                    |           |\n|   discard, waste   | They are **discarding** their **waste** in the middle of the night. |           |\n|       moral        |                         moral issue                          |           |\n|  toxic, substance  |                       toxic substance                        | 有毒物质  |\n|     workforce      |                    a company's workforce                     | 全体员工  |\n|       inform       |                                                              |           |\n|       annual       |                       an annual report                       |           |\n\n### 听力-2023年12月第一套（对话）\n\n|  词汇/短语  |           搭配/例句            |                  释义                   |\n| :---------: | :----------------------------: | :-------------------------------------: |\n|  limelight  |     being in the limelight     | 暴露在公共视野下/<br />公众注意力的中心 |\n|  alleviate  | Alleviate the obesity problem. |                                         |\n|  acclaimed  |                                |                                         |\n|  celebrity  |                                |         名声，名望；名人，明星          |\n| right after |                                |                 紧接着                  |\n| speculation |                                |                                         |\n|             |                                |                                         |\n\nOur guest is John Williams. The name may not sound familiar to you. But John was once a **acclaimed** basketball player. John, you stunned the fans by leaving the sport at just 25. Why did you retire so early?\n\nMega, I love being an athlete, but I didn't love being a **celebrity**. I was in the limelight when I was still a high school student. I went professional **right after** the high school graduation, which was a mistake.\n\nMost people wouldn't be able to resist the lure of such a high salary. When you left the sport, there was **speculation** the that you were having issues with your teammates, or even in injury.\n\nNot at all. It was hard to quit. I was tempt to stay in the game. As for money, I turn to professional at 18, so I actually earned a lot, save the most of it. <u>Because I have great financial advisor. I knew basketball wasn't a career with a lot of **longevity** for most players.</u>\n\n<u>Okay, that was 20 years ago, and you're back in the news.</u> You've created the foundations that works to get more kids playing team sports. Why?\n\nI went to university, and I study public health and learned a seriousness of obesity epidemic. Particularly among kids and adolescents in poor communities. I speed last 2 decades tying to alleviate the problem.\n\n==**六级听力过程中听到材料中的原词，还需要把上下文的情景词写在旁边，例如什么地方，什么时期，谁干的。**==\n\n### 阅读\n\n|  词汇/短语   |          搭配/例句          |        释义        |\n| :----------: | :-------------------------: | :----------------: |\n|   formula    |                             |     公式；方法     |\n|  underlying  |                             |  在……之下；潜在的  |\n|     wage     |                             |        工资        |\n| conventional |                             |       传统的       |\n| propagation  |                             |        宣传        |\n|  relentless  |                             |                    |\n|    rival     | it lakes for obvious rivals |                    |\n|    while     |                             |       尽管……       |\n|     cult     |                             |    邪教（狂热）    |\n|   campaign   |                             |        竞选        |\n|  candidate   |                             |       竞选人       |\n| compensation |                             | 补助，补偿金，薪水 |\n|  prioritise  |                             |                    |\n|  quarterly   |                             |      一季度的      |\n| illustration |                             |                    |\n|   premium    |                             |   高额薪酬，奖金   |\n|   unerring   |                             |       无误的       |\n|     lens     |                             | （相机）镜头，观点 |\n|  negotiate   |                             |        谈判        |\n| a tug of war |                             |    拉锯战，拔河    |\n|   widening   |                             |     越来越宽的     |\n\n首先做Section C，再做Section B，最后做Section A。\n\n对于Section C，做题步骤如下：\n\n- 读题： 只读题目，不读选项，目的是预测文章主题和大致定位。\n- 读文章：用文章对应选项。原则：问什么就答什么。\n\n==**正确选项的特征：原文的同义转述——Paraphrase。**==\n\n## 5-6\n\n|  词汇/短语  |                            例句                             |    释义    |\n| :---------: | :---------------------------------------------------------: | :--------: |\n|    waste    | They are discarding their waste in the middle of the night. |            |\n| aspiration  |                                                             |            |\n| comply with |                     comply with the law                     |            |\n| orientation |                                                             | 方向，定位 |\n\n## 5-8\n\n|     词汇/短语     |                         例句                          |                   释义                   |\n| :---------------: | :---------------------------------------------------: | :--------------------------------------: |\n|     privilege     |                                                       | （因为非常富有或社会地位高而享有）特权的 |\n|  underprivileged  |                                                       |          相对贫困，生活水平底下          |\n|      assert       |                                                       |                坚称，断言                |\n|      forgive      |                                                       |               免除（债务）               |\n|    proposition    |                                                       |               法律修正议案               |\n|     eliminate     |                                                       |                   消除                   |\n|     affluent      |                                                       |              富裕的，富足的              |\n|   in attendance   |                                                       |                   出席                   |\n|    outstanding    |                                                       |                未被偿还的                |\n|    counterpart    |                                                       |              对应的人或事务              |\n|      address      |                                                       |                   解决                   |\n|      esteem       |           You have earn my highest esteem.            |                尊重，敬重                |\n|       merit       |               The plan has some merit.                |                 优秀品质                 |\n|     formulate     |                I'm formulate the plan.                |                规划，策划                |\n|     forecast      |         weather forecast(also weather report)         |                   预报                   |\n|  radical change   |                                                       |                彻底的变化                |\n|      confine      |         Confine your questions with the case.         |                                          |\n|    orientation    |                                                       |                方向，定位                |\n|     prestige      |    The higher the house, the greater the prestige.    |                威信，声望                |\n|     intrigue      |                                                       |               激起……的欲望               |\n|       stake       |                   bet and the stake                   |           打赌的内容和**赌注**           |\n|       debt        |                                                       |                   欠款                   |\n|     aggravate     |                                                       |               加重，使恶化               |\n| ==**commodity**== |            We'd be treated as a commodity.            |                   商品                   |\n|     disclose      |              disclose military secrets.               |                透露，披露                |\n|    proposition    |                                                       |   （尤指商业上或者政治上的）观点，主张   |\n|     eliminate     | One government **proposition** is to **eliminate**... |                   消除                   |\n|     affluent      |                                                       |                  富裕的                  |\n|      outrage      |                                                       |                  使愤怒                  |\n|    outrageous     |                                                       |                骇人听闻的                |\n|   approximately   |                                                       |                大概，大约                |\n|      federal      |                                                       |                  联邦的                  |\n|      reveal       |     **Federal** Reserve data **reveals** that...      |                表明，显现                |\n\n## 5-10\n\n|  词汇/短语   |                             例句                             |        释义        |\n| :----------: | :----------------------------------------------------------: | :----------------: |\n|    humble    |                                                              |       简陋的       |\n|    abode     |                                                              |        住处        |\n|  relaxation  |                      morning relaxation                      |        祷告        |\n|   glorious   |                                                              |   辉煌的，绚丽的   |\n|   paradise   |                                                              |        天堂        |\n|    hatch     |                                                              |        孵化        |\n|    impart    |                                                              |     传达、传授     |\n|   furnish    |              **furnished with** a chair or two.              | 布置、配备家具陈设 |\n|  interfere   |                                                              |     妨碍、干扰     |\n|    gross     |                                                              | 总的，总共；恶心的 |\n|  intricate   |                                                              |     错综复杂的     |\n|    immune    |                                                              |       免疫的       |\n|   magnify    |                 Lens can magnify the image.                  |        放大        |\n|  identical   |                                                              |      完全相同      |\n|  engagement  |                                                              |        订婚        |\n|  fluctuate   |                     The game fluctuated.                     |      上下浮动      |\n|  permanent   |               permanent job/ permanent damage                |       永久的       |\n|   precise    |                                                              |       精确的       |\n|  reference   |                                                              | 提到；参考；推荐信 |\n|   shuttle    |                                                              |      航天飞机      |\n| simultaneous | The arrests must be made as close to **simultaneous** as possible. |       同步的       |\n|  speculate   |                   I don't need speculate.                    |     推断，推测     |\n|    suburb    |                                                              |        教区        |\n| superiority  |                     military superiority                     |     优越，优势     |\n|   tedious    |                                                              |     冗长乏味的     |\n|   trivial    |           I don't care about such trivial things.            | 琐碎的，微不足道的 |\n|   vigorous   |                                                              |     精力旺盛的     |\n|   withdraw   |                                                              |        撤退        |\n|   flourish   |                                                              |     繁荣，兴旺     |\n| manufacture  |    （动词）My company ==**manufacture**== toys and games.    | 大量生产，大量制造 |\n\n","tags":["English"]},{"title":"JavaScript学习笔记","url":"/2024/04/30/JavaScript-Learning/","content":"\n# JavaScript学习笔记\n\n- 参考课程：[【狂神说Java】JavaScript最新教程通俗易懂](https://www.bilibili.com/video/BV1JJ41177di?t=1.9)\n\n## 1 JavaScript引入\n\n### 1.1 在网页上输出 Hello world\n\nJavaScript代码需要放在HTML文件中，下面是一个简单的HTML代码示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Debussy</title>\n    </head>\n    <body>\n        <script src=\"source/js/test.js\"></script>\n    </body>\n</html>\n```\n\n可以在`.html`文件中的script标签中书写JavaScript代码，但是一般采用下面的方式进行外部引入。\n\n```html\n<script src=\"source/js/test.js\"></script>\n```\n\n**该标签需要放在body标签的最后，以加快网页的加载速度**。不要使用合并标签。在`test.js`文件中书写下面的代码调用一个弹窗，显示`Hello world!`。\n\n```javascript\nalert(\"Hello world!\");\t\t// 在弹窗中输出Hello World！\n```\n\n`alert`函数的参数是一个字符串，字符串可以用单引号引出，也可以用双引号。这一点和C语言不同。\n\n![](https://raw.githubusercontent.com/sukiDebussy/pictures/master/test/image-20240430134221441.png)\n\n弹窗命令可以用来方便地调试程序。前端写弹窗非常简单，至少相比于后端要简单不少。\n\n### 1.2 JavaScript 简介\n\nJavaScript是一门弱脚本语言（可能是世界上最流行的脚本语言），源代码不需要通过编译，而是由浏览器解释运行，**用于控制网页的行为**。JavaScript只能在浏览器引擎上运行，浏览器引擎类似发动机引擎，JavaScript相当于汽油，而浏览器本体相当于一台汽车。我们可以用汽油和发动机去驱动汽车，也可以去浇灌农田。类似地，使用JavaScript可以实现网页端的开发，在不同的运行环境下（应用场景不同）也可以发生不同的作用，例如使用Electron（NodeJS）框架实现桌面端应用的开发。\n\n只掌握JavaScript只能说掌握了前端开发的基础。一般的前端开发可以分为原生开发和框架开发，说白了，就是是否重复造轮子的选择问题，或者说是否造好看的轮子的问题。目前流行的前端框架有Vue，UI框架有阿里巴巴出品的Ant-Design等。\n\n==JavaScript的线上环境和开发环境可能不一致==：ECMAScript是JavaScript遵循的标准，最新已经更新到ES6了。但是大多数浏览器支持仍然停留在ES5，所以需要WebPack等工具将ES6代码打包成ES5，才能在大多数浏览器上运行。\n\n### 1.3 CSS 和 CSS 预处理器\n\n> 这一块知识和JavaScript关系不大，但是也记录在此，因为它和前端开发结合的相当紧密。\n\nCSS层叠样式是一门标记语言，它本身并不是编程语言，**它不支持自定义变量和引用，不具备任何语法支持特性**。这成为了它的主要缺陷，CSS的语法不够强大，不能嵌套书写，模块化开发中需要写很多重复的选择器；没有合理的样式复用和维护机制，逻辑上相关的属性必须以字面量的形式重复输出，导致难以维护。为了解决这一问题，实际开发中通常使用一种称为CSS预处理器的工具。\n\nCSS预处理器定义了一种新的语言，它的基本思想是，用一种专门的编程语言，为CSS增加一些编程的特性。将CSS作为目标生成文件（编译目标），而开发者需要书写生成CSS语言的逻辑就可以方便地实现网页样式的维护和更新。\n\n常用的CSS预处理器由SASS和LESS，二者相比LESS更加简单，更常用。LESS基于NodeJS，功能比SASS简单，但是解析效率不如SASS。实际开发中LESS也够用了。\n\n## 2 基本语法入门\n\n### 2.1 变量\n\nJavaScript中定义变量非常简单，甚至不需要显式地指定变量类型，统统用`var`表示。变量名中可以添加`$`，也可以以它开头，只不过不常用。甚至可以使用中文命名和赋值，不过应该和使用的中文编码方式有关，容易报错，感觉还是不要使用为妙。\n\n```javascript\nvar a = 1;\nvar b = 2;\nvar str = \"Hello world!\";\n```\n\n### 2.2 条件判断\n\n```javascript\nvar score = 80;\n\nif (score > 60 && score < 90) {\n    alert(\"合格\");\n}\nelse if (score >= 90) {\n    alert(\"优秀\");\n}\nelse {\n    alert(\"不合格\");\n}\n```\n\n单条语句可以省略花括号。\n\n### 2.3 基本的浏览器操作\n\n调试除了用`alert()`或者`console.log()`函数输出信息外，还可以断点调试。这里以Edge浏览器为例。\n\n![](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240430145609448.png)\n\n点击F12打开控制台，在源代码处可以打断点。刷新网页即可直接运行。在右侧监视窗口可以添加变量名用于监视变量的变化。\n\n除此之外，常用的窗口及其作用如下所示：\n\n- 元素窗口（Element）：一般用于查看网页元素和复刻网页；\n- 控制台（Console）：用于打印变量，执行控制命令等；\n- 源代码（Source）：查看源码，断点调试；\n- 网络（Network）：抓包；\n- 应用程序（Application）：查看Cookie。\n\n### 2.4 常见数据类型\n\n在网页上常见的数据类型不止数字和字符串。图像，文本，音频，视频等都是数据类型。JavaScript的数据类型非常庞杂。\n\n#### 2.4.1 数字 Number\n\nJavaScript不区分小数和整数，所有数字统一都是`number`类型。JavaScript支持直接表示整数、浮点数、负数、科学计数法（例如`1.23e3`）、`NaN`、`Infinity`（无穷大）。所有数字都是`number`类型。\n\n#### 2.4.2 字符串\n\n可以用单引号引出，也可以用双引号引出。\n\n#### 2.4.3 布尔值\n\n包含true和false，没有什么特别。\n\n#### 2.4.4 逻辑运算\n\n与`&&`或`||`非`!`。\n\n#### 2.4.5 判等运算符\n\n- `=`：赋值符号，不是判断等于符号\n- `==`：等于（类型不同，但是值相同，也会返回true，例如`1 == '1'`）\n- `===`：绝对等于（类型相同，值相同，==实际开发中常用绝对等于判断两个元素是否相等==）\n\n等于和绝对等于可以看作JavaScript的一个缺陷，坚持一定使用绝对等于进行比较。下面是一些注意事项：\n\n- `NaN`：不和任何数字相等，包括自己。如果要判断一个变量是否是`NaN`只能使用`isNaN()`函数。\n- 计算机表示浮点数的精度有限，在计算机中`1/3 === 1 - 2/3`一定会返回一个`false`。尽量避免使用浮点数进行运算。\n\n#### 2.4.6 空指针和未定义\n\n空指针`null`没有什么稀奇，但是未定义`undefined`在其他语言中并不常见。例如此时有一个数组，如果要打印的数组元素超过了数组的长度，JavaScript不会报错，而是会返回一个`undefined`类型。\n\n#### 2.4.7 数组\n\nJavaScript对变量的类型没有明确定义，那么对于数组中是否存储相同类型的元素也不关心。JavaScript中的数组可以存放任意类型的变量。数组可以使用`[]`或者使用`Array()`方法定义，但是使用方括号对于代码的可读性贡献更好。\n\n```javascript\nvar arr = [1, 2, 3, 4, \"hello\", null, true, undefined];\n// 也可以采用下面的方式定义一个数组\nvar arr2 = new Array(1, 2, 3, 4, \"world\", undefined);\n```\n\n#### 2.4.8 对象\n\nJavaScript中定义一个对象可以直接使用大括号`{}`定义。任何数据类型都要用`var`定义，对象也不例外。**这里的对象并不是面向对象的概念，没有封装、继承、多态等概念**。\n\n```javascript\nvar person = {\n    mame: \"Include everything\",\n    age: 20,\n    tags: [\"Piano\", \"C\", \"Verilog\"]\n};\n```\n\n注意：**JavaScript中定义对象不需要先定义一个类**。内部变量通过键值对的方式给出，值同样可以是不同的类型，具体的格式和json格式非常相似，每个属性之间使用逗号分隔，最后一个键值对不需要加逗号。使用类似`person.name`的方式访问元素即可，没有什么稀奇。\n\n### 2.5 严格检查模式\n\n由于JavaScript中对于变量的定义十分宽泛，甚至直接使用类似Python语法定义变量都不会报错：\n\n```javascript\ni = 0;\n```\n\n实际上，上面的语句将`i`定义为一个全局变量。如果采用全局变量，会导致代码之间程序耦合的问题，会带来很多毁灭性的bug。在ES5中，采用`var`定义的变量是局部变量，而在ES6中，使用`let`和`const`定义变量才会被当作局部变量。\n\n```javascript\nlet a = 0;\nconst b = 1;\n```\n\n在JS代码之前加入语句`'use strict';`语句即可开启严格检查模式，写这一行代码必须写在第一行。编译器会检查变量是否被定义，未经定义的变量会直接报错。使用后还可以规避一些JavaScript中变量定义随意性导致的问题。\n\n```javascript\n'use strict';\n            \na = 1;\n```\n\n![image-20240430230041181](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240430230041181.png)\n\n### 2.6 分支与循环\n\n分支循环的语法基本和C语言一模一样。注意某些特殊的写法如`for ... in ...`语句或者某些对象的循环方法即可（例如`forEach()`）。\n\n## 3 数据类型详解及其属性和方法\n\n### 3.1 字符串\n\n正常的字符串使用单引号或者双引号引用。需要注意转义字符的引用，例如`\\n`、`\\'`、`\\r`、`\\t`等。\n\n转义字符甚至可以直接打印ASCII编码字符和UniCode字符：\n\n```javascript\nconsole.log('\\u4e2d');  \t// 中\nconsole.log('\\x41');\t\t// A\n```\n\nJavaScript支持多行字符串编写，多行字符串需要使用`` `字符引用：\n\n```javascript\nlet msg = `hello\nworld\n你好`;\n```\n\n 在ES6中，模板字符串用下面的格式进行书写，注意使用多行字符串符号引用。（ES6新特性）\n\n```javascript\nlet name = 'Include everything';\nlet age = 20;\n\nlet msg = `Hello, ${name}, your age is ${age}`;\n```\n\n字符串是不可变型变量。直接修改字符串中的某个字符不会报错，但是修改也不生效。\n\n```javascript\nlet name = 'Zhang Yun';\nconsole.log(name[0]);\nname[0] = 'A';\nconsole.log(name);\t\t// 仍然打印 Zhang Yun\n```\n\n下面是一些字符串常用的属性和方法：\n\n```javascript\nlet name = 'Zhang Yun';\n\nconsole.log(name.length);\nconsole.log(name.toUpperCase());\nconsole.log(name.toLowerCase());\n\nconsole.log(name.indexOf('n'));\t\t\t// 返回找到第一个该字符的下标\nconsole.log(name.substring(1));\t\t\t// 截取第一个字符之后所有的字符\nconsole.log(name.substring(1, 3));\t\t// 截取字符串，截取范围是[1, 3)\n```\n\n### 3.2 数组\n\nJavaScript中的数组和其他语言有相同的地方，比如都可以使用下标访问元素。但是也有不同的地方：\n\n- JavaScript的数组可以存放任意数据类型的元素\n- 数组长度可变，且可以直接被赋值。如果赋值小于当前长度，多余元素会直接丢失；如果赋值大于当前长度，会直接添加几个空元素。空元素的类型是undefined。\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\n\narr.length = 8;\nconsole.log(arr);\narr.length = 2;\nconsole.log(arr);\n```\n\n下面给出数组的一些常用方法：\n\n- `indexOf()`\n\n```javascript\nlet arr = [1, 2, 3, 4, 5, \"1\", \"2\"];\n\nconsole.log(arr.indexOf(1));\t\t// 0\nconsole.log(arr.indexOf(\"1\"));\t\t// 5，数组中数字和字符串不同\n```\n\n- `slice()`：截取Array的一部分（返回一个新的数组）\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\n\nconsole.log(arr.slice(2))\t\t// [3, 4, 5]\nconsole.log(arr.slice(2, 4))\t// [3, 4]，截取范围是[a, b)，和substring类似，返回一个数组\n```\n\n- 添加或删除元素（修改原来的数组）\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\n\narr.push('a', 'b')\t\t\t // 压入尾部\narr.pop()\t\t\t\t\t// 弹出尾部\narr.unshift('head1', 'head2') // 压入头部\t\t\t\narr.shift()\t\t\t\t\t// 弹出头部\n```\n\n- 排序算法（修改原来的数组）\n\n```javascript\nlet arr = ['B', 'C', 'A'];\n\narr.sort();\t\t\t\t// 正序\narr.reverse();\t\t\t// 逆序\n```\n\n- 拼接（返回一个新的数组）\n\n```javascript\nlet arr = ['B', 'C', 'A'];\n\nconsole.log(arr.concat([1, 2, 3]));\t\t// ['B', 'C', 'A', 1, 2, 3]\n```\n\n- 连接（返回一个字符串，由元素和连接符组成）\n\n```javascript\nlet arr = ['B', 'C', 'A'];\n\nconsole.log(arr.join('-'));\t\t// 'B-C-A'\n```\n\n数组还有一个方法，可以实现类似循环的操作：`forEach`，里面的参数是一个方法，方法的参数即为数组的元素。\n\n```javascript\nlet arr = [3, 2, 44, 32, 1, 2];\n\narr.forEach(function (value){\n    console.log(value);\n})\n            \n// for (index in object)\nfor (let i in arr) {\n    console.log(arr[i]);\t\n}\n\n// for (element of object)\nfor (let i of arr) {\n    console.log(i);\n}\n```\n\n`for in`遍历数组下标还存在一个特性，它不仅会返回元素的下标，还会返回元素对应的键：\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\narr.name = 'debussy';\t\t// arr 会新增一个键值对对象\nconsole.log(arr);\nfor (let x in arr) {\n    console.log(x);\t\t\t// 打印1， 2， 3， 4， 5和 name\n}\n```\n\n\n\n### 3.3 对象\n\nJavaScript中的对象用键值对的方式书写。这里的对象不是面向对象中的对象概念，没有封装、继承、多态的概念。**所有的键都是字符串，值可以是任意类型**。\n\n可以使用delete命令动态删除对象中的某一属性。\n\n```javascript\nlet person = {\n    name: \"Debussy\",\n    age: 20,\n    score: 80\n};\ndelete person.score;\nconsole.log(person);\nconsole.log(person['age'])\n```\n\n![image-20240501143302426](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240501143302426.png)\n\n直接给不存在的属性赋值，不会报错，JavaScript会自动添加属性。\n\n```javascript\nperson.tags = ['C', 'Verilog'];\n```\n\n![image-20240501143432663](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240501143432663.png)\n\n使用`in`关键字判断属性是否在这个对象中：\n\n```javascript\nconsole.log('age' in person);\t\t// true\nconsole.log('toString' in person);\t// true, 'toString'是父类的属性, person继承了父类的属性\n```\n\n判断属性是否属于自身：\n\n```javascript\nconsole.log(person.hasOwnProperty('toString'));\t\t// false\nconsole.log(person.hasOwnProperty('name'));\t\t\t// true\n```\n\n对象定义中如果后面的定义和前面的定义冲突，那么以后面的为准（后面的定义会覆盖前面的）：\n\n```javascript\nlet Debussy = {\n    name: \"Debussy\",\n    age: 20,\n    isMarried: false,\n    skills: [\"HTML\", \"CSS\", \"JS\"],\n    greet: function() {\n        console.log(\"Hello, my name is \" + this.name);\n    },\n\n    name: \"Include everything\"\n}\n\nDebussy.greet();\t// Hello, my name is Include everything\n```\n\n\n\n### 3.4 Map和Set\n\nMap和Set是ES6的新特性。Map在组成上很像Python的字典，由键值对组成。定义的时候可以通过一个二维数组来定义。\n\n```javascript\nlet map = new Map([[\"tom\", 90], [\"bob\", 80], [\"alice\", 70]]);\n\nlet score = map.get(\"tom\"); // get方法获取键值对的值\nconsole.log(score);\n\nmap.set(\"tom\", 100);        // 设置已有键值对的值\nconsole.log(map);\n\nmap.set(\"Debussy\", 85);     // 通过set创建新键值对\nconsole.log(map);\n\nmap.delete(\"tom\");          // 删除键值对\nconsole.log(map);\n```\n\nSet是一个无序不重复的集合。一般只能用来判断某元素是否在Set中存在。定义时使用一个数组定义，但是多余的元素会被自动忽略。\n\n```javascript\nlet set = new Set([1, 1, 1, 3]);\nconsole.log(set);           // set去重\nconsole.log(set.size);\t\t// 2\n\nset.add(2);                 // set添加元素\nconsole.log(set);\t\t   // {1, 2, 3}\nset.delete(1);              // set删除元素\nconsole.log(set);\t\t   // {2, 3}\nconsole.log(set.has(3));    // set判断元素是否存在，返回true\n```\n\n### 3.5 iterator 迭代器\n\n迭代器是Python中一个经典的概念，JavaScript中也有类似的结构。迭代器是ES6的新特性，迭代器的主要作用是遍历对象中所有的元素，实际上很多数据结构都可以自己写函数或者方法来实现迭代器的功能，但是利用迭代器可以简化代码书写，提高效率。\n\n在数组中可以使用`for in`和`for of`迭代所有的元素，前者迭代下标，后者迭代元素：\n\n```javascript\n// for (index in object)\nfor (let i in arr) {\n    console.log(arr[i]);\t\n}\n\n// for (element of object)\nfor (let i of arr) {\n    console.log(i);\n}\n```\n\n`for of`这种方法在Map和Set中也同样适用。只有支持迭代器的对象才可以使用`for of`遍历。\n\n```javascript\nlet map = new Map([[\"tom\", 90], [\"bob\", 80], [\"alice\", 70]]);\n\nfor (let x of map) {\n    console.log(x);     // 以数组的方式返回所有的键值对\n}\n\nlet set = new Set([1, 1, 1, 3]);\nfor (let x of set) {\n    console.log(x);\n}\n```\n\n## 4 函数和面向对象\n\n方法是一种函数。对象内定义的函数称为方法，其他函数称为普通函数。方法和函数的格式相同，只是二者的定义的位置不同。\n\n### 4.1 函数\n\n下面是一个简单的返回绝对值的函数：\n\n```javascript\nfunction abs(x) {\n    if (x >= 0)\n        return x;\n    else \n        return -x;\n}\n```\n\n如果函数没有正常返回，或者传参错误，JavaScript会返回NaN或者Undefined，而不是报错。\n\n![image-20240502111921868](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240502111921868.png)\n\n函数也可以使用下面的方式定义，定义一个匿名函数，并且将该函数赋值给一个变量，这个变量就会称为该函数的名称，通过`abs`就可以调用函数。两种函数定义的方式等价。\n\n```javascript\nlet abs = function (x) {\n    if (x >= 0)\n        return x;\n    else\n        return -x;\n}\n```\n\nJavaScript的参数的个数甚至都可以不确定。可以传递任意个参数，甚至不传递参数，函数在运行时都不会报错。这就需要程序员在设计函数时考虑到这些异常。\n\n如果传入参数不存在，或者类型错误，可以使用`typeof`关键字获取参数类型，并通过`throw`关键字抛出一个异常：\n\n```javascript\nlet abs = function (x) {\n    if (typeof x !== \"number\") {\n        // throw \"x is not a number!!!\";\n        throw new Error(\"x must be a number\");\t\t// 该种写法会返回错误出现的位置\n    }\n    if (x >= 0)\n        return x;\n    else\n        return -x;\n}\n```\n\n![image-20240502113736228](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240502113736228.png)\n\n`arguments`是JavaScript免费赠送的关键字，它会获取传入函数的所有参数，并且返回一个对应的数组：\n\n```javascript\nlet abs = function (x) {\n    console.log(\"x = \" + x);\n    for (let i = 0; i < arguments.length; i++) {\n        console.log(\"arguments[\" + i + \"] = \" + arguments[i]);\n    }\n    if (x >= 0)\n        return x;\n    else\n        return -x;\n}\n```\n\n![](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240502113820501.png)\n\n使用`arguments`会有一个问题：它包含所有的参数，但是有时我们又恰恰想用剩余的参数来进行操作。这时可以使用`rest`关键字（ES6新特性）获取除了已经定义的参数之外的所有参数。\n\n如果不使用缺省参数关键字`...`获取剩余的参数：\n\n```javascript\nfunction func(a, b) {\n    console.log(\"a = \" + a);\n    console.log(\"b = \" + b);\n    if (arguments.length > 2) {\n        for (let i = 0; i < arguments.length; i++) {\n            ...\n        }\n    }\n}\n```\n\n如果使用`...`关键字，注意要在参数栏写明可能有缺省参数，且它只能写在最后，必须使用`...`标识表明rest是缺省的，`...`后是缺省参数的数组名称：\n\n```javascript\nfunction func(a, b, ...rest) {\n    console.log(\"a = \" + a);\n    console.log(\"b = \" + b);\n    console.log(rest);\n}\n```\n\n![](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240502115043254.png)\n\n> 经过测试，rest并不是一个关键字，它相当于承载剩余参数的一个变量名而已，该变量是一个数组。\n\n### 4.2 变量的作用域\n\n#### 4.2.1 函数之间变量作用域\n\nJavaScript中的变量虽然可以在首次赋值时默认被直接声明，但是不可以在未定义时赋值给其他变量。下面的程序会立即报错，因为`x = x + 1`中等号右边的`x`没有被定义。可见使用`var`定义的变量是有作用域的。\n\n```javascript\nfunction func1() {\n    var x = 1;\n    x = x + 1;\n    console.log(x);\n}\nx = x + 1;\n```\n\n如果两个函数中使用了相同的变量名，则两个变量名互不影响。\n\n```javascript\nfunction func1() {\n    var x = 1;\n    x = x + 1;\n    console.log(x);\n}\nfunction func2() {\n    var x = 'A';\n    x = x + 1;\n    console.log(x);\n}\nfunc1();\t\t// 输出2\nfunc2();\t\t// 输出A1（返回一个字符串，而不是返回B）\n```\n\n**JavaScript的函数声明或者函数体甚至可以写在函数内部**。下面的表达依然是合法的。并且内部函数可以使用外部函数的变量，但是外部函数不能访问内部函数的变量。\n\n```javascript\n// 外部函数可以访问内部函数变量，反之不可以\nfunction func_outer()\n{\n    var a_outer = 1;\n    function func_inner()\n    {\n        var a_inner = 2;\n        console.log(a_outer);\n        console.log(a_inner);\n    }\n    func_inner();\n    console.log(a_inner);   // ReferenceError: a_inner is not defined\n}\nfunc_outer();\n```\n\n如果内部函数和外部函数声明了相同的变量名，则内部变量使用内部变量，外部变量使用外部变量。虽然从结果上看互不影响，但是官方的说法是：JavaScript函数查找变量从自身函数开始，从内向外查找。假设外部存在这个同名变量，则内部变量屏蔽外部函数变量。\n\n#### 4.2.2 同一函数先后定义变量作用域\n\nJavaScript中，虽然使用未定义的变量给其他变量赋值会导致程序报错，**但是如果这个变量在后面的程序段中定义，则不会报错，而是会将定义提前，但是定义时的赋值并不会提前**。这时使用这个变量会返回一个`undefined`。也可以理解为编译器会自动将所有变量的定义提前，但是赋值并不会提前。所以通用的做法是将所有变量写在程序的头部，以预防这种情况的发生。这是在JavaScript建立之初就存在的特性，有一定的优点，但是不利于代码维护。\n\n```javascript\nvar x = 1 + y;\nconsole.log(x);\t// 1 + undefined = NaN\nvar y = 10;\t\t// 如果写y = 10则会直接报错，因为y = 10不是一个定义\nconsole.log(y);\n```\n\n#### 4.2.3 全局作用域和`window`对象\n\nJavaScript中，`window`是一个特殊的对象，它代表浏览器，同时也是JavaScript的唯一的全局作用域。直接定义的变量都是**全局变量**，同时也是`window`的子属性。有些函数可以直接调用，例如`alert()`， 它是一个**全局函数**，它是`window`对象的子方法。==任何变量（函数也可以视为变量）如果没有在函数的作用范围内找到，就会向外查找，直到全局作用域`window`。如果在全局作用域都没有找到才会报错。==\n\n```javascript\nvar x = \"Hello!\";\n\n// 下面三种写法等价\nalert(x);\nwindow.alert(x);\nwindow.alert(window.x);\n```\n\nJavaScript中的变量可以是任意类型，当然也可以是一个函数。我们当然可以使用一个与原有函数同名的变量，将另一个函数赋值给这个变量，则原函数就会被新函数覆盖。\n\n```javascript\nvar x = \"Hello!\";\nvar y = \"World!\";\n\nwindow.alert(x);\n\nvar old_alert = window.alert;\nwindow.old_alert(x);\n\nvar alert = function () {\n    \n}\nwindow.alert(y);     // 失效，浏览器不会弹出窗口\n\nalert = window.old_alert;\nwindow.alert(x);     // 重新有效\n```\n\n所有的全局变量都会绑定到`window`对象下，包括不同文件中定义的全局变量。假设不同文件中定义了相同的变量，就会导致冲突。解决方法是在每个JS文件中定义一个特殊的独一无二的对象，将这个对象作为当前文件的全局空间，可以在一定程度上减少冲突。\n\n```javascript\nvar Debussy = {};\t// 当前文件的全局变量\n\n// 定义变量\nDebussy.name = \"Debussy\";\nDebussy.age = 20;\n\n// 定义方法\nDebussy.add = function (a, b) {\n    return a + b;\n};\n```\n\n#### 4.2.4 局部作用域`let`和常量`const`\n\n`let`和`const`都是ES6的新特性。现在已不建议使用`var`关键字定义常量，否则可能出现这样的Bug（特性？）：\n\n```javascript\nfunction func1 () {\n    for (var i = 0; i < 10; i++) {\n        console.log(i);\n    }\n    console.log(i); // 打印出了10，i是函数作用域下的变量，所以可以打印出来\n}\nfunc1();\n```\n\n但是这样的特性很多时候是不利于代码编写的。所以使用关键字`let`定义`i`就不存在这样的问题。\n\n```javascript\nfunction func1 () {\n    for (let i = 0; i < 10; i++) {\n        console.log(i);\n    }\n    console.log(i);     // ReferenceError: i is not defined\n}\nfunc1();\n```\n\n`const`的官方名是只读变量，它只可以在定义时被赋值，之后都不能被赋值。`const`声明的变量不可修改，数组和对象除外（数组和对象仅仅不能全部更改）。\n\n```javascript\nconst year = 2024;  // 使用const必须要在声明时就初始化数值\n// year = 2023;\nconsole.log(year);\n```\n\n### 4.3 方法的定义和调用\n\nJavaScript中的方法定义十分简单。放置在对象中的函数就称为方法，甚至方法定义可以直接写在对象中：\n\n```javascript\nlet Debussy = {\n    name: 'Debussy',\n    age: 20,\n    height: 170,\n    weight: 60,\n    isMarried: false,\n    hobby: 'Music',\n    sayHello: function() {\n        console.log('Hello!');\n    },\n    sayName: function() {\n        console.log(this.name);     // this指向当前对象\n        console.log(this);\n    }\n}\nDebussy.sayHello();\nDebussy.sayName();\n```\n\n在对象中只有两种元素：属性和方法。`this`始终指向调用它的对象。如果将方法采用下面的写法，同样可以定义：\n\n```javascript\nlet Debussy = {\n    name: 'Debussy',\n    age: 20,\n    height: 170,\n    weight: 60,\n    isMarried: false,\n    hobby: 'Music',\n    sayHello: function() {\n        console.log('Hello!');\n    },\n    sayName: getName\n}\n\nfunction getName() {\n    console.log(this.name);\n}\n\nDebussy.sayHello();\nDebussy.sayName();      // Debussy\n\ngetName();      // 无法正常输出\n```\n\n在其他编程语言中，一般而言`this`指向的对象都不可更改，但是在JavaScript中可以通过`apply()`函数定义当前调用这个函数的对象。所有的函数对象都有apply方法。例如，将上面代码块中的`getName()`改为下面的形式就可以正常输出：\n\n```javascript\ngetName.apply(Debussy);\ngetName.apply(Debussy, []);     // 空参数可以不写，也可以用一个空数组代替\n```\n\n### 4.4 原型继承和类继承\n\n#### 4.4.1 原型继承\n\n早期的JavaScript程序并没有类定义，所以只能采用这种方法。如果一个对象想要获得另一个对象的部分属性，需要指定对象的`__proto__`属性来继承原有的对象，即指向一个原型。这样的编程方法虽然实现了类似面向对象的效果，但是没有强调面向对象的概念。\n\n```javascript\nlet Student = {\n    name: 'Debussy',\n    age: '20',\n    run: function(){\n        console.log(this.name + ' is running.');\n    },\n}\n\nlet PrimaryStudent = {\n    __proto__: Student,     // 通过__proto__属性，继承Student\n    name: 'xiaoming',\n    grade: '1',\n}\n```\n\n![](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240503200736201.png)\n\n如果需要更改继承对象，只需要更改`__proto__`指向的对象即可（可能是原型继承唯一的优点）。任何对象都有原型属性，且这个原型属性可以追本溯源到`object`对象，包括`object`对象自身。\n\n#### 4.4.2 类继承\n\n类继承也是ES6新增的方法。在ES6之前，通过下面的方法创建一个学生类：\n\n```javascript\n// 创建一个学生类（指定一个函数当作构造函数）\nfunction Student(name) {\n    this.name = name;\n}\nStudent.prototype.sayName = function() {\n    console.log('My name is ' + this.name);\n}\nlet s = new Student(\"Debussy\");\t\t// s 是一个对象\ns.sayName();\n```\n\n在ES6之后才可以使用`class`关键字：\n\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    sayName() {\n        console.log('My name is ' + this.name);\n    }\n}\n\nlet s = new Student(\"Debussy\");\ns.sayName();\n```\n\n使用下面的方法继承：\n\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    sayName() {\n        console.log('My name is ' + this.name);\n    }\n}\n\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name);            // 调用父类的构造函数\n        this.grade = grade;\n    }\n\n    sayGrade() {\n        console.log('I am in grade ' + this.grade);\n    }\n}\n\nlet ps = new PrimaryStudent(\"Debussy\", 1);\nps.sayName();\nps.sayGrade();\n```\n\n> 简单的回顾一下**构造函数、原型和实例**的关系：**每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针**，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。\n>\n> ——摘自《javascript高级程序设计》\n\n![image-20240503205317107](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240503205317107.png)\n\n## 5 内部对象\n\nJavaScript中万物皆对象。常见的对象类型有如下几种（可以用`typeof`关键字获取）\n\n- `'number'`：所有数字均为`'number'`类型，部分整数和浮点数。包括`NaN`。\n- `'string'`\n- `'boolean'`\n- `'function'`：函数名称的类型为`'function'`\n- `'object'`：数组和对象均为`'object'`\n- `'undefined'`：`undefined`独成一个类型，类型就是`'undefined'`\n\n### 5.1 Date对象\n\n可以使用`Date`获取当前时间和计算时间：\n\n```javascript\nlet now = new Date();\n\nconsole.log(now);\nconsole.log(now.getFullYear());     // 年份\nconsole.log(now.getMonth());        // 月份，1月为0\nconsole.log(now.getDate());         // 日期\nconsole.log(now.getDay());          // 星期几，0为星期天\nconsole.log(now.getHours());        // 小时\nconsole.log(now.getMinutes());      // 分钟\nconsole.log(now.getSeconds());      // 秒\nconsole.log(now.getMilliseconds()); // 毫秒\nconsole.log(now.getTime());         // 距1970年1月1日0时0分0秒的毫秒数（时间戳）\n```\n\n可以使用时间戳创建时间：\n\n```javascript\nlet time = new Date(1714713565465);\n\nconsole.log(time);\nconsole.log(time.toLocaleString());         // 2024/5/3 13:19:25\nconsole.log(time.toLocaleDateString());     // 2024/5/3\nconsole.log(time.toLocaleTimeString());     // 13:19:25\n\nconsole.log(time.toGMTString());            // Fri, 03 May 2024 05:19:25 GMT\n```\n\n### 5.2 JSON对象\n\nJSON是一种数据格式，用于传输特定数据，本质上就是一串字符串。JavaScript中一切皆为对象，任何JavaScript支持的类型都可以用JSON来表示。\n\n```javascript\nlet Debussy = {\n    name: \"Debussy\",\n    age: 20,\n    isMarried: false,\n    skills: [\"HTML\", \"CSS\", \"JS\"],\n    greet: function() {\n        console.log(\"Hello, my name is \" + this.name);\n    }\n}\n\nlet jsonDebussy = JSON.stringify(Debussy);  // 返回一个字符串，函数会被省略'{\"name\":\"Debussy\",\"age\":20,\"isMarried\":false,\"skills\":[\"HTML\",\"CSS\",\"JS\"]}'\n\nlet parsedDebussy = JSON.parse(jsonDebussy);// 返回一个对象\n```\n\n## 6 BOM和DOM\n\n### 6.1 BOM对象\n\n在Web开发中，常用B（Browser）代表浏览器，S（Server）代表服务端。BOM全称为Browser Object Module，即浏览器对象模型。\n\n#### 6.1.1 `window`（重要）\n\n`window`对象可以有两层含义：一可以指浏览器窗口，二是可以指唯一的全局作用域。`window`有下面的一些常用的方法和属性：\n\n```javascript\nwindow.alert('Hello');\nwindow.console.log('World');\n\nconsole.log(window.innerHeight);\nconsole.log(window.innerWidth);\nconsole.log(window.outerHeight);\nconsole.log(window.outerWidth);\n```\n\n![image-20240504002359321](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240504002359321.png)\n\n#### 6.1.2 `navigator`（不建议使用）\n\n`navigator`封装了浏览器的信息，它是`window`的一个属性。它比较常用的用法是获取当前的浏览器信息和用户信息，比如可以获知当前的网页打开使用的是什么浏览器，是手机浏览器还是PC浏览器，浏览器内核是什么，PC的OS信息等：\n\n![image-20240504003301819](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240504003301819.png)\n\n大多数时候不会使用`navigator`对象，因为它可以被人为修改。不建议使用这些属性来判断和编写代码。\n\n#### 6.1.3 `screen`\n\n代表屏幕信息。浏览器的功能远比想象的强大，它甚至可以操作浏览器之外的很多部件，获取很多信息。\n\n![image-20240504003632278](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240504003632278.png)\n\n#### 6.1.4 `location`（重要）\n\n`location`可以获取当前页面的URL信息。\n\n```javascript\nconsole.log(location.host);     // 主机 127.0.0.1:5500\nconsole.log(location.href);     // http://127.0.0.1:5500/test.html\nconsole.log(location.pathname); // /test.html\n\n// location.reload();   // 刷新网页\n\nlocation.assign(\"https://www.baidu.com\");   // 跳转到百度（将该网站连接到一个新地址）\n```\n\n#### 6.1.5 `document`\n\n`document`代表当前的页面的html文件中的DOM文档树。可以通过`document`获取当前浏览器中文档树的节点。能获取就能做到增删改查。\n\n![image-20240504005547447](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240504005547447.png)\n\n``` html\n<dl id=\"abc\">\n    <dt>Debussy</dt>\n    <dd>Debussy is learning JavaScript</dd>\n    <dd>Debussy must learning FPGA</dd>\n</dl>\n<script>\n    // \"use strict\";\n\n    let dl = document.getElementById('abc');\n    console.log(dl);\n</script>\n```\n\n![image-20240504005954901](https://cdn.jsdelivr.net/gh/sukiDebussy/pictures@master/test/image-20240504005954901.png)\n\n`document`还可以获取cookie。cookie包含了客户端的一些本地信息，通过这些信息，可能直接通过劫持这些cookie来非法登录网页，非法获取隐私等。服务器端可以设置cookie为httpOnly，就可以规避这个问题，提高网页使用安全性。\n\n#### 6.1.6 `history`\n\n代表浏览器的历史记录，通过这个对象可以前进和后退，但是不建议使用这种方法。浏览器网页的跳转还是建议在服务端实现。\n\n```javascript\nhistory.forward();\nhistory.back();\n```\n\n### 6.2 DOM对象\n\n![](https://s2.loli.net/2024/05/04/I6qfArds9cC2SuB.png)\n\nDOM全称Document Object Module，即文件对象模型。整个浏览器网页就是一个树形结构。通过操作DOM，可以实现网页元素的行为。**要操作一个Dom节点，就必须先获得这个Dom节点**。\n\n- 更新：更新Dom节点，例如给某个节点添加某个属性；\n- 遍历：得到Dom节点，例如可以通过`id`属性得到节点；\n- 删除：删除Dom节点；\n- 添加：添加一个新的节点。\n\n一个标签就是一个节点，在网页上就体现为一个元素。\n\n#### 6.2.1 获取Dom节点\n\n首先介绍（复习）一些常见的Dom节点及其作用：\n\n- `div`：`div` HTML 元素是流式内容的**通用容器**。它对内容或布局没有影响。除非以某种方式使用 CSS 对其进行样式设置（例如，直接应用样式，或者对其父元素应用某种布局模型，如弹性盒子），否则它对内容或布局没有影响。\n\n- `dl`：list列表\n  - `dt`：title表头\n  - `dd`：description描述\n\n![](https://s2.loli.net/2024/05/04/cy7hODngUR9r6aj.png)\n\n```html\n<div id=\"father\">\n    <dl>\n        <h1 class=\"title\">This is a h1 node</h1>\n        <dt>This is a dt node</dt>\n        <dd class=\"description\">Lorem ipsum dolor sit amet consectetur adipisicing elit. Omnis laborum quia quos\n            sint repellat aut!\n            Fugiat et soluta exercitationem omnis rerum doloremque, doloribus, beatae culpa asperiores non minus\n            temporibus suscipit.</dd>\n    </dl>\n\n    <p>Lorem ipsum dolor, sit amet consectetur adipisicing elit. Perferendis dolorem nostrum, aliquid aspernatur\n        cumque at illum, accusamus reprehenderit eaque fugit reiciendis itaque. At enim vero maiores eius laboriosam\n        sunt natus.</p>\n</div>\n<script>\n    // \"use strict\";\n\n    let h1 = document.getElementsByTagName(\"h1\");               // 通过标签名获取元素\n    let dd = document.getElementsByClassName(\"description\");    // 通过类名获取元素\n    let div_father = document.getElementById(\"father\");         // 通过id获取元素\n\n    let div_children = div_father.children;             // 获取父元素下的所有子元素\n    let div_child_1 = div_father.firstElementChild;     // 获得第一个子元素 dl\n    let div_child_2 = div_father.lastElementChild;      // 获得最后一个子元素 p\n\n</script>\n```\n\n上面的代码是原生代码，后续基本不使用。之后一般使用`jQuery()`获取Dom节点，但是了解原生写法还是很有必要的。\n","tags":["JavaScript"]},{"title":"腐蚀和膨胀算法","url":"/2024/02/15/ED-algorithms/","content":"\n## 一、形态学图像处理算法\n\n所谓形态学图像处理，就是将数学形态学作为工具，从图像中提取用于表达和描绘区域形状的图像成分，如边界、骨架等。\n\n形态学图像处理算法的主要应用场景有以下几点：\n\n1. 边沿检测\n2. 形态学滤波\n3. 骨架检测\n\n****\n\n## 二、腐蚀和膨胀\n\n腐蚀和膨胀是形态学中最基础的两种算法。\n\n### 2.1 腐蚀\n\n在谈论腐蚀运算的时候，我们通常认为至少有两个对象，其中一个是**结构单元**，相当于一个“吸血鬼”；另一个是被腐蚀的图形A，相当于“吸血鬼的可活动区域”。易得：如果想要使结构单元一直处于被腐蚀的图形内，结构单元的中心点将围成一个与原图形类似的区域B，且这个新的区域B一定比被腐蚀的图形区域A小。区域A和区域B作异或运算，就可以得到区域A的边界了。\n\n在计算机视觉系统中，结构单元的移动并不是连续的，而是根据像素离散地一步步移动的。结构单元可以是不同的形状，但是关键在于确定结构单元的中心点像素，并且结构单元的所有像素都必须处于区域A中。如果结构单元完全在区域A中，那么结构单元的中心点像素的位置就可以输出，这些中心点像素位置组成的图形即为区域B。\n\n![image-20240216000845529](image-20240216000845529.png)\n\n腐蚀缩小或者细化了二值图像中的物体。同时，腐蚀可以看成形态学的滤波操作，这种操作**将小于结构单元的图像细节从图像中滤除**。\n\n![image-20240216001437327](image-20240216001437327.png)\n\n### 2.2 膨胀\n\n膨胀过程实际上就是腐蚀的相反过程，即保证结构单元有一部分与被膨胀的区域重叠A即可。实际算法实现中，我们将结构单元遍历所有的像素点，并且将符合要求的像素点输出出来，得到的区域即为膨胀之后的区域。\n\n一个常见的应用场景是，当一个图片的一些细节（字符）有断裂，我们就可以使用一个结构单元对图像进行膨胀运算。\n\n![image-20240216163411952](image-20240216163411952.png)\n\n## 三、开操作和闭操作\n\n在实际的使用中，腐蚀和膨胀一般都不会单独使用，而是会相互结合。二者不同的先后执行顺序会对图像有两种不同的效果：\n\n1. 开操作：先腐蚀，后膨胀。适用场景：平滑物体的轮廓，断开较窄的狭颈，并消除细小的突出物。\n2. 闭操作：先膨胀，后腐蚀。使用场景：同样会平滑物体轮廓的一部分，但是与开操作相反，它通常会弥合较窄的间断和细长的沟壑，消除小的空洞，填补轮廓线中的断裂。\n\n![image-20240216164744612](image-20240216164744612.png)\n\n两种操作各有优缺点。以指纹图像的识别为例，开操作虽然消除了图像中所有的噪声，但是会导致指纹图像出现新的断裂。为了弥补这种现象，我们可以对开操作之后的图像再执行一次闭操作，这样就有可能获得一个较为清除明晰的图像。\n\n![image-20240216164820537](image-20240216164820537.png)\n","tags":["FPGA","图像处理","Verilog"]},{"title":"直方图统计和直方图均衡算法","url":"/2024/02/14/histogram/","content":"## 一、图像的直方图\n&emsp;&emsp;直方图其实就是柱状图。对于一个图像而言，每一个像素都有一个对应的灰度值。一个图像的灰度直方图横坐标为灰度，纵坐标为某灰度像素的数量。对于常用的RGB-888格式的图像，每一个颜色的数值范围均为 $0-2^8$ ，即 $0-255$ ，对于灰度图，横坐标的取值范围（能够显示的灰度等级，也反映了摄像头获取图像颜色的精确程度）也是 $0-255$。![Histogram of Digital Image](image.png)\n\n&emsp;&emsp;**图像的灰度直方图可以反映出图像的以下信息：**\n1. **亮度信息**：比较亮的图像柱状图的纵坐标主要分布在右侧，比较暗的图像柱状图主要分布在左侧。\n2. **对比度信息**：低对比度的图像柱状图分布较为集中，高对比度的图像柱状图分布较为分散。如下图所示，对比度越低，各个像素点的灰度差异较小，柱状图分布更集中，分辨图像信息更困难。![image2](image2.png)\n\n## 二、直方图均衡\n&emsp;&emsp;直方图均衡即将图片的灰度直方图“拉伸和平均”的操作，来增强图像的对比度。在拉伸的过程中需要尽量保持每个灰度级的像素数量不变。直方图均衡算法可以由以下的公式给出：\n$$\ns_k=\\frac {L-1}{MN} \\sum_{j=0}^k n_j,\tk=0,1,2,...,L-1\n$$\n\n​\t上式中，$M$、$N$为图像的宽和高，$L$表示输入图像的灰度等级的数目，在RGB-888格式中，$L=2^8$。$k$表示某像素点的灰度级，$s_k$表示变换后输出的灰度级大小（位置不变）。$n_j$表示灰度等级为$j$​的像素点的数量。注意：求和时不单单求特定灰度级的像素数，而是将该灰度级及其之前所有灰度级的像素数做一个累加（累积）。这个累积之后得到的直方图称为累积直方图。累积的结果乘以一个固定的系数，即可得到输出的灰度等级。均衡后的直方图是由处理后的图像得到的，而不是由某个公式直接得到的。\n\n## 三、Verilog代码编写思路\n\n​\t首先要得到每一帧图像中对应灰度级像素出现的次数。以RGB-888格式为例，可以定义256个计数器，遍历图像中的每一个像素，遍历到对应灰度等级的计数器依次+1，最后即可得到直方图均衡之前的灰度直方图。但是直接定义256个计数器很浪费FPGA资源，对于访问也不是很方便，于是我们可以通过定义一个RAM来实现。每一个灰度等级对应RAM的一个特定的地址。\n\n### 3.1 如何使用RAM统计像素的灰度级\n\n\n\n\n\n\n\n","tags":["FPGA","Verilog"]},{"title":"ZYNQ学习笔记","url":"/2024/02/09/ZYNQ-Learning/","content":"****\n## 一、ZYNQ 简介\n### 1.1  概述\n&emsp;![PS and PL in ZYNQ](image.png)\n\n&emsp;&emsp;ZYNQ，即Zynq-7000 All Programmable Soc (APSoC)，赛灵思公司(AMD Xilinx)推出的新一代全可编程片上系统。实际上，**ZYNQ = PS(Processing System，处理系统，ARM) + PL(Program Logic，可编程逻辑，实际上就是FPGA)**。两个系统可以独立使用，二者通过AXI高速接口进行数据通信。\n\n&emsp;&emsp;ZYNQ将处理器的软件可编程性与FPGA的硬件可编程性进行完美结合，以提供无与伦比的系统性能、灵活性和可扩展性。ZYNQ可以依靠片上的ARM内核运行Linux系统。\n\n&emsp;&emsp;ZYNQ是基于ARM处理器的SoC，可满足复杂嵌入式系统的高性能、低功耗和多核处理器等要求。SoC(System on Chip)和早期的SoB(System on Board)相对应。SoC的成本更低，能在不同的系统单元之间实现更快更安全的数据传输，具有更高的系统运行速度，更低的功耗，更小的物理尺寸和更高的可靠性。\n\n\n\n&emsp;&emsp;Soc主要可以分为以下三类：\n1. 基于ASIC的Soc；\n2. 可编程的片上系统(SOPC, System on Programmable Chip, 即FPGA)：灵活性很高，但是要实现这样的功能要使用的资源很多，导致最后实现的功能受限；\n3. 全可编程片上系统(APSoC, All Programmable SoC，即ZYNQ)。\n### 1.2 PL（FPGA）简介\n\n&emsp;&emsp;FPGA（Field Programmable Gate Array，现场可编程门阵列），一种可以通过编程来修改其逻辑功能的数字集成电路（芯片）。Xilinx公司对自己的最小可编程单元起名为可配置逻辑块CLB（Configurable Logic Block），一个CLB由两个片（Slice）组成，每个片中包含多个查找表LUT（Look Up Table）和触发器FF（Flip-Flop）。**PL部分就是7系列的FPGA部分，型号不同，资源不同，例如逻辑单元，内部存储器数量，乘法器，高速接口等。**\n\n&emsp;&emsp;FPGA的架构如下所示：\n- **可编程IO单元**：可将引脚配置为上拉或下拉、驱动电流、电平标准、输入、输出或双向等。\n- **可编程逻辑单元（CLB）**\n- **底层嵌入功能单元**：例如PLL、DSP、时钟管理等\n- **嵌入式块RAM（Block RAM）**：用来存储数据\n- **硬核**：例如XADC，不是每一个厂家的每一个芯片都有。XADC可以实现高速AD转换，检测片上温度和电压等。\n- **布线资源**\n- ...\n\n&emsp;&emsp;有以下两种PL架构，对应不同的ZYNQ型号\n- Artix-Based devices：Z-7010，Z-7015，Z-7020\n- Kintex-Based devices：Z-7030，Z-7045，Z-7100\n\n\n\n### 1.3 PS（处理系统）简介\n\nPS端集成了两个ARM Cortex-A9处理器，AMBA（Advanced Microcontroller Bus Architecture）互联，内部存储器，外部存储器接口和多种外设。外设主要包括USB总线接口，I2C总线接口，CAN总线接口，UART接口，GPIO，GigE，以太网接口，SD/SDIO接口等。\n\n在PS端有一部件称为APU（Application Processor Unit），可称为应用处理单元。内部除了两颗ARM核之外还有以下部件需要关注：\n\n- GIC（General Interrupt Controller）：通用中断控制器，用于接收来自外设的IRQ（Interrupt Request，中断请求）。\n- OCM（On Chip Memory）：片上存储单元，主要用于管理一块256K的SRAM。\n- Memory Interface：PS端内部有两个存储器接口，可以连接和管理芯片外部的存储器芯片，用于实现高速的数据存储、处理和传输。\n\n### 1.4 ZYNQ GPIO分布\n\n- MIO（Multiplexing IO）：存在于PS端，是可复用的IO。IO管脚的配置在一定程度上保留了灵活性以满足不同外设的需求。\n- EMIO（Extensible MIO）：存在于PL端，是对MIO的扩展。如果MIO不够用，这些端口可以直接从PL端扩展到PS端，被PS端直接使用。\n\nZYNQ有118个GPIO，分为54个MIO和64个EMIO。其中有32个MIO（Bank 0），22个MIO（Bank 1），32个EMIO（Bank 2），32个EMIO（Bank 3）。在概念的分组上，PS端有Bank 0和Bank 1两个分组，PL端有Bank 2和Bank 3两个分组。需要注意这些分组都是概念上的，在硬件上的分组有其他的形式。在硬件上，Bank 500、Bank 501、Bank 502是PS端的分组，Bank 13、Bank 33、Bank 34、Bank 35是PL端的分组。\n\n## 二、AXI 总线\n\n### 2.1 概述\n\nAXI（Advanced eXtensible Interface）是一种总线协议，该协议是 ARM 公司提出的 AMBA（Advanced Microcontroller Bus Architecture）3.0 协议中最重要的部分，是一种面向高性能、高带宽、低延迟的片内总线。**它的地址/控制和数据相位是分离的**，支持不对齐的数据传输，同时在突发传输中，只需要首地址，同时分离的读写数据通道、并支持显著传输访问和乱序访问，并更加容易就行时序收敛。AXI 是 AMBA 中一个新的高性能协议。AXI 技术丰富了现有的 AMBA 标准内容，满足超高性能和复杂的片上系统（SoC）设计的需求。\n\n**AXI 总线是连通 PS 和 PL 的一个总线协议，最终的形式就相当于 PL 块作为一个 IP Core 挂载在 AXI 总线上，然后由 PS 调用**。Xilinx 从 6 系列的 FPGA 开始对 AXI 总线提供支持，目前使用 AXI4 版本（在A7系列芯片中就可以找到AXI4总线协议）。\n\n### 2.2 AXI 总线协议种类\n\n\n\n- AXI4（For high-performance memory-mapped requirements）：主要面向高性能**地址映射**通信的需求，是面向地址映射的接口，允许最大256轮的数据突发传输；\n- AXI4-Lite（For Simple, low-throughput memory-mapped communication）：是一个轻量级的地址映射单次传输接口，占用的逻辑资源较少；\n- AXI4-Stream（For high-speed streaming data）：面向高速数据流传输，去掉了地址传输，允许无限制的数据突发传输规模。\n\n\n\n### 2.3 AXI 总线协议接口\n\n&emsp;![image-20240321213944787](image-20240321213944787.png)\n\n- AXI-GP（General-Purpose，4个通道）：通用AXI接口，包括两个32位主设备接口（用于发送）和两个32位从设备接口（用于接收），通过该接口可以访问PS的片内外设；\n- AXI-HP（High-Performance，4个通道）：高性能/带宽的标准的接口，PL模块作为主设备连接，**主要用于PL访问PS上的存储器接口**，可以访问芯片外部的DDR芯片或片上的OCM（SRAM）；\n- AXI-ACP（Accelerator Consistency Port，1个通道）：加速器一致性端口，ARM多核架构下的一种接口，用来管理DMA之类的不带缓存的AXI外设，PS（APU）作从设备用于接收来自PL的数据。\n\n&emsp;![image-20240321220104190](image-20240321220104190.png)","tags":["FPGA","ZYNQ"]},{"title":"Hexo 操作记录","url":"/2024/02/08/img-delete/","content":"## 添加文章\n\n&emsp;&emsp;创建文章时务必使用`hexo new new_blog`命令创建，以在`_posts`文件夹中生成与文章同名的文件夹。`new_blog`不能是中文名称。\n\n## 添加图片到文章中\n\n&emsp;&emsp;将图片复制到与文章的Markdown文件同名的文件夹下后，直接使用格式`![Img Description](Img.png)`在文章中添加图片。注意：==图片名称、路径以及图片描述都不能带中文，否则会遇到图片无法正常显示的问题。==\n\n## 删除文章\n\n1. 删除`_posts`下的所有与文章有关的文件\n2. 删除`.deploy_git`文件夹\n3. 执行`hexo clean`命令\n4. 执行`hexo g`命令\n5. 执行`hexo d`命令\n"},{"title":"基于FPGA设计的矿洞辅助工作芯片","url":"/2024/02/08/chip-designer/","content":"## 一、应用背景\n\n矿产资源勘探一直是一个国家重要的经济支柱，矿洞和矿场也是很多工人重要的工作场地。但是，与矿产相关的工作环境普遍存在极高的危险性，需要矿工拥有较强的安全防护意识。尽管如此，矿洞、矿场事故仍频频发生。为了提高矿工工作环境的安全度，我们设计了这款基于FPGA设计的矿洞辅助工作芯片，在芯片外部添加特定的模块电路，即可实现不同的功能，为矿工的工作提供辅助，对现场工作环境的安全性进行实时检测和预警。\n\n## 二、机器人功能设计\n\n机器人采取**小车+机械臂**为结构主体，在上面添加不同功能的模块扩展相应功能。\n\n1. 通过**视觉模块**和**机械臂模块**结合实现工具的抓取和归位。\n2. 通过**温湿度传感器模块**实时检测当前工作环境的温湿度，超过阈值则通过**蜂鸣器（音响）**进行预警。\n3. 通过**火焰传感器**和**烟雾传感器**结合检测当前工作环境附近是否存在矿产资源的自燃现象，如果有则通过**蜂鸣器（音响）**进行报警。\n4. 通过**光亮度传感器**实时检测当前工作环境亮度，当亮度低于阈值时自动开启灯光进行辅助照明。\n5. 通过**CO气敏传感器（MQ-7）**实时检测当前工作环境的CO浓度含量，如果超过阈值则通过**蜂鸣器（音响）**报警。\n6. 通过**超声波传感器**进行避障。\n7. 通过**蓝牙模块**和**语言控制模块**实现一定的人机交互，例如用手机APP连接蓝牙控制小车移动，控制小车机械臂，通过语言控制模块控制照明灯开关等。\n8. 通过**人体传感器（雷达跟踪）**检测附近工人位置，进行实时跟随。\n\n## 三、芯片模块设计\n\n\n![models](models.png)\n","tags":["FPGA","集创赛"]},{"title":"蓝桥杯比赛","url":"/2024/02/07/BlueBridge/","content":"# 蓝桥杯比赛\n\n## 竞赛提供文件\n\n1. USB驱动程序（一般不会用到）\n\n2. 底层驱动代码参考\n\n   - DS18B20温度传感器，一般省赛不会用，该配件在扩展版上\n\n   - I2C驱动程序（重要）\n\n3. 芯片资料：板子上几乎所有芯片的手册，大多数用不到，重要的在于STM32的编程手册和参考手册。客观题中相关问题可以直接查阅手册。\n\n4. 库文件（STM32CubeMX配置完成之后该文件也一般不会用到）\n\n5. 液晶驱动参考程序（重点）\n\n   开始比赛后直接将HAL_06_LCD直接复制一份作为工程模板使用，不用再写额外的LCD调试程序（其CubeMX工程版本可能有问题，**需要事先注意版本移植的问题**）。\n\n6. CT117E_M4_SCH.pdf：开发板原理图\n\n7. CT117E_M4产品手册：开发板开发手册，包含原理图\n\n##  客观题部分\n\n客观题包含：STM32相关、数电模电部分知识。主要看平时的积累，STM32相关不会的要会查阅手册。\n\n## 程序设计部分\n\n### 1 LED模块\n\n1. 修改CubeMX配置：IO引脚，IO端口\n2. 注意事项：使用LED时必须将`LE`引脚拉高，不用时拉低\n3. 使用说明：高电平LED熄灭，低电平LED点亮\n\n### 2 按键KEY模块\n\n1. 修改CubeMX配置：IO引脚，IO端口\n\n2. 注意事项：未按下为高电平，按下为低电平\n\n3. 按键需要消抖，但是不能阻塞程序，可以参考以下的扫描方式\n\n   ```c Key Scan Code\n   uint8_t KeyScanCount = 0;\n   uint8_t KeyScanFlag = 0;\n   uint8_t KeyPressedFlag = 0;\n   uint8_t KeyFlag = 0;\n   \n   /* 按键扫描函数，20ms扫描一次实现消抖 */\n   void Key_Scan(void)\n   {\n       for (uint8_t i = 0; i < 4; i ++)\n       {\n           if (HAL_GPIO_ReadPin(KeyPort[i], KeyPin[i]) == GPIO_PIN_SET)    // lift up\n           {\n           \tKeyPressedFlag &= ~(1 << i);   \n           }\n           else if ((KeyPressedFlag & (1 << i)) == 0)      // first push\n           {\n               if (HAL_GPIO_ReadPin(KeyPort[i], KeyPin[i]) == GPIO_PIN_SET)\n               {\n                   return;\n               }\n               KeyFlag |= (1 << i);\n               KeyPressedFlag |= (1 << i);\n           }\n       }\n   }\n   \n   void Key_Process(void)\n   {\n       printf(\"keyFlag: %X\\n\", KeyFlag);\n   }\n   ```\n\n   \n\n### 3 串口收发模块\n\n1. CubeMX配置USART1初始化；\n\n2. CubeMX使能USART中断；\n\n3. 串口发送：重写`fputc()`函数（**赛前多写几次**），即可直接使用`printf()`函数进行串口发送；\n\n   ```c\n   int fputc(int ch, FILE* f)\n   {\n   \tHAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFF);\n       return ch;\n   }\n   ```\n\n4. 串口接收：使能中断接收，之后重写中断服务函数`HAL_UART_RxCpltCallback()`函数即可：\n\n   ```C\n   HAL_UART_Receive_IT(&huart1, uartRxBuffer, 1);\n   ```\n\n   ```c\n   void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n   {\n       /* 接收处理代码 */\n   }\n   ```\n\n   \n\n### 4 ADC模块\n\n1. 初始化：直接在CubeMX中配置即可，推荐使用DMA循环模式触发ADC采样\n\n2. 开始采样：在程序初始化中直接开启DMA模式ADC采样。之后CPU就不用处理ADC的内容了，需要数据直接读取即可。\n\n   ```c\n   uint16_t AdcBuffer[2] = {0};\n   \n   HAL_ADC_Start_DMA(&hadc2, (uint32_t*)Adcbuffer, 2);\n   ```\n\n3. 读取数据：直接读取即可，DMA会自动更新其中的内容。\n\n   ```c\n   AdcDisplay[0] = Adcbuffer[0] * 3.3 / 4095.0;\n   AdcDisplay[1] = Adcbuffer[1] * 3.3 / 4095.0;\n   ```\n\n4. 数据不稳定：延长采样时间\n\n### 5 PWM输出\n\n1. 初始化：直接在CubeMX中配置好TIM与对应通道的PWM输出![PWM Config](PWM.png)\n\n2. 开始/停止：直接调用库函数即可\n\n   ```c\n   HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);\n   ```\n\n3. 调节频率设置占空比：直接设置PSC（预分频系数，一般不用设置这个）、ARR（自动重装载值）、CCRx（捕获比较寄存器）的值即可：\n\n   ```c\n   htim3.Instance->ARR = 49;\n   htim3.Instance->CCR2 = 99;\n   ```\n\n   \n\n### 6 测量PWM频率和占空比\n\n使用定时器的捕获中断服务回调函数处理。\n\n```c\nuint8_t pwmMode = 0;\nuint32_t pwmPosTime = 0;\ndouble pwmPredTime = 0;\ndouble pwmDuty = 0;\ndouble pwmFreq = 0;\n\nvoid HAL_TIM_IC_CaptureCallBack(TIM_HandleTypeDef *htim)\n{\n    if (pwmMode == 0)\n    {\n        htim2.Instance->CCER |= 0x0002;     // set rising detection to falling detection\n        htim2.Instance->CNT = 0;\n        pwmMode = 1;\n    }\n    else if (pwmMode == 1)\n    {\n        htim2.Instance->CCER &= ~0x0002;    // set falling detection to rising detection\n        pwmPosTime = htim2.Instance->CCR1;\n        pwmMode = 2;\n    }\n    else if (pwmMode == 2)\n    {\n        htim2.Instance->CCER |= 0x0002;     // set rising detection to falling detection\n        pwmPredTime = htim2.Instance->CCR1;\n        htim2.Instance->CNT = 0;\n        pwmMode = 1;\n        pwmDuty = (100.0 * pwmPosTime) / (pwmPredTime);\n        pwmFreq = 10000000.0 / (pwmPredTime);\t\t// 1000000.0 = 主频/PSC\n    }\n}\n```\n\n1. 第一次先捕获上升沿，清空计数器，并将两个时间设置为0；\n2. 第二次捕获下降沿，记录高电平时间；\n3. 第三次再捕获上升沿，记录整个周期的时间；\n4. 主函数中判断是否已经捕获完成一个周期，将pwmMode设置为0开始下一次捕获；\n\n## 整体代码编写思路\n\n题目的主要特点：\n\n1. 任务要求多\n2. 实时处理和显示\n3. 同一任务的处理时间间隔有一定要求\n\n从`HAL_06_LCD`工程开始逐步添加功能。最重要的编写思想是==前后台系统==。\n\n### 前后台系统\n\n前后台系统即将每一个模块及其相应称为一个任务。使用SysTick计时，每隔一段时间执行一次某个任务，同时该任务不能占据太长时间。以下面的代码为例：\n\n```c\nvoid SysTick_Handler(void)\n{\n    /* USER CODE BEGIN SysTick_IRQn 0 */\n\n    /* USER CODE END SysTick_IRQn 0 */\n    HAL_IncTick();\n    /* USER CODE BEGIN SysTick_IRQn 1 */\n\n    if (KeyScanCount == 49)         // 任务 1：按键扫描，50ms一次\n    {\n        KeyScanCount = 0;\n        KeyScanFlag = 1;\n    }\n    else \n    {\n        KeyScanCount ++;\n    }\n    \n    if (LEDRefreshCount == 99)         // 任务 2：LED刷新，100ms一次\n    {\n        LEDRefreshCount = 0;\n        LEDRefreshFlag = 1;\n    }\n    else \n    {\n        LEDRefreshCount ++;\n    }\n    \n    if (LCDRefreshCount == 99)         // 任务 3：LCD刷新，100y\n    {\n        LCDRefreshCount = 0;\n        LCDRefreshFlag = 1;\n    }\n    else \n    {\n        LCDRefreshCount ++;\n    }\n\n    /* USER CODE END SysTick_IRQn 1 */\n}\n```\n\n在`main`函数中：\n\n```c\nvoid main(void)\n{\n    /* Init code */\n\n    while (1)\n    {\n        if (LCDRefreshFlag == 1) {      // LCD刷新\n            LCD_Refresh();\n            LCDRefreshFlag = 0;\n        }\n        if (LEDRefreshFlag == 1) {      // LED刷新\n            LED_Refresh();\n            LEDRefreshFlag = 0;\n        }\n        if (KeyScanFlag == 1) {         // 按键扫描\n            Key_Scan();\n            KeyScanFlag = 0;\n        }\n        if (KeyFlag || KeyLongFlag) {   // 长按检测\n            Key_Process();\n            KeyFlag = 0;\n            KeyLongFlag = 0;\n        }\n    }\n}\n```\n\n","tags":["嵌入式开发","STM32","蓝桥杯"]},{"title":"about","url":"/about/index.html"},{"title":"projects","url":"/projects/index.html"},{"url":"/categories/index.html"},{"title":"friends","url":"/friends/index.html","content":"\n目前没有任何友链."},{"url":"/search/index.html"},{"url":"/tags/index.html"}]