[{"title":"腐蚀和膨胀算法","url":"/2024/02/15/ED-algorithms/","content":"\n## 一、形态学图像处理算法\n\n所谓形态学图像处理，就是将数学形态学作为工具，从图像中提取用于表达和描绘区域形状的图像成分，如边界、骨架等。\n\n形态学图像处理算法的主要应用场景有以下几点：\n\n1. 边沿检测\n2. 形态学滤波\n3. 骨架检测\n\n****\n\n## 二、腐蚀和膨胀\n\n腐蚀和膨胀是形态学中最基础的两种算法。\n\n### 2.1 腐蚀\n\n在谈论腐蚀运算的时候，我们通常认为至少有两个对象，其中一个是**结构单元**，相当于一个“吸血鬼”；另一个是被腐蚀的图形A，相当于“吸血鬼的可活动区域”。易得：如果想要使结构单元一直处于被腐蚀的图形内，结构单元的中心点将围成一个与原图形类似的区域B，且这个新的区域B一定比被腐蚀的图形区域A小。区域A和区域B作异或运算，就可以得到区域A的边界了。\n\n在计算机视觉系统中，结构单元的移动并不是连续的，而是根据像素离散地一步步移动的。结构单元可以是不同的形状，但是关键在于确定结构单元的中心点像素，并且结构单元的所有像素都必须处于区域A中。如果结构单元完全在区域A中，那么结构单元的中心点像素的位置就可以输出，这些中心点像素位置组成的图形即为区域B。\n\n![image-20240216000845529](image-20240216000845529.png)\n\n腐蚀缩小或者细化了二值图像中的物体。同时，腐蚀可以看成形态学的滤波操作，这种操作**将小于结构单元的图像细节从图像中滤除**。\n\n![image-20240216001437327](image-20240216001437327.png)\n\n### 2.2 膨胀\n\n膨胀过程实际上就是腐蚀的相反过程，即保证结构单元有一部分与被膨胀的区域重叠A即可。实际算法实现中，我们将结构单元遍历所有的像素点，并且将符合要求的像素点输出出来，得到的区域即为膨胀之后的区域。\n\n一个常见的应用场景是，当一个图片的一些细节（字符）有断裂，我们就可以使用一个结构单元对图像进行膨胀运算。\n\n![image-20240216163411952](image-20240216163411952.png)\n\n## 三、开操作和闭操作\n\n在实际的使用中，腐蚀和膨胀一般都不会单独使用，而是会相互结合。二者不同的先后执行顺序会对图像有两种不同的效果：\n\n1. 开操作：先腐蚀，后膨胀。适用场景：平滑物体的轮廓，断开较窄的狭颈，并消除细小的突出物。\n2. 闭操作：先膨胀，后腐蚀。使用场景：同样会平滑物体轮廓的一部分，但是与开操作相反，它通常会弥合较窄的间断和细长的沟壑，消除小的空洞，填补轮廓线中的断裂。\n\n![image-20240216164744612](image-20240216164744612.png)\n\n两种操作各有优缺点。以指纹图像的识别为例，开操作虽然消除了图像中所有的噪声，但是会导致指纹图像出现新的断裂。为了弥补这种现象，我们可以对开操作之后的图像再执行一次闭操作，这样就有可能获得一个较为清除明晰的图像。\n\n![image-20240216164820537](image-20240216164820537.png)\n","tags":["FPGA","图像处理","Verilog"]},{"title":"直方图统计和直方图均衡算法","url":"/2024/02/14/histogram/","content":"## 一、图像的直方图\n&emsp;&emsp;直方图其实就是柱状图。对于一个图像而言，每一个像素都有一个对应的灰度值。一个图像的灰度直方图横坐标为灰度，纵坐标为某灰度像素的数量。对于常用的RGB-888格式的图像，每一个颜色的数值范围均为 $0-2^8$ ，即 $0-255$ ，对于灰度图，横坐标的取值范围（能够显示的灰度等级，也反映了摄像头获取图像颜色的精确程度）也是 $0-255$。![Histogram of Digital Image](image.png)\n\n&emsp;&emsp;**图像的灰度直方图可以反映出图像的以下信息：**\n1. **亮度信息**：比较亮的图像柱状图的纵坐标主要分布在右侧，比较暗的图像柱状图主要分布在左侧。\n2. **对比度信息**：低对比度的图像柱状图分布较为集中，高对比度的图像柱状图分布较为分散。如下图所示，对比度越低，各个像素点的灰度差异较小，柱状图分布更集中，分辨图像信息更困难。![image2](image2.png)\n\n## 二、直方图均衡\n&emsp;&emsp;直方图均衡即将图片的灰度直方图“拉伸和平均”的操作，来增强图像的对比度。在拉伸的过程中需要尽量保持每个灰度级的像素数量不变。直方图均衡算法可以由以下的公式给出：\n$$\ns_k=\\frac {L-1}{MN} \\sum_{j=0}^k n_j,\tk=0,1,2,...,L-1\n$$\n\n​\t上式中，$M$、$N$为图像的宽和高，$L$表示输入图像的灰度等级的数目，在RGB-888格式中，$L=2^8$。$k$表示某像素点的灰度级，$s_k$表示变换后输出的灰度级大小（位置不变）。$n_j$表示灰度等级为$j$​的像素点的数量。注意：求和时不单单求特定灰度级的像素数，而是将该灰度级及其之前所有灰度级的像素数做一个累加（累积）。这个累积之后得到的直方图称为累积直方图。累积的结果乘以一个固定的系数，即可得到输出的灰度等级。均衡后的直方图是由处理后的图像得到的，而不是由某个公式直接得到的。\n\n## 三、Verilog代码编写思路\n\n​\t首先要得到每一帧图像中对应灰度级像素出现的次数。以RGB-888格式为例，可以定义256个计数器，遍历图像中的每一个像素，遍历到对应灰度等级的计数器依次+1，最后即可得到直方图均衡之前的灰度直方图。但是直接定义256个计数器很浪费FPGA资源，对于访问也不是很方便，于是我们可以通过定义一个RAM来实现。每一个灰度等级对应RAM的一个特定的地址。\n\n### 3.1 如何使用RAM统计像素的灰度级\n\n\n\n\n\n\n\n","tags":["FPGA","Verilog"]},{"title":"ZYNQ学习笔记","url":"/2024/02/09/ZYNQ-Learning/","content":"****\n## 一、ZYNQ 简介\n### 1.1  概述\n\n![image-20240321192846700](image-20240321192846700.png)\n\n&emsp;&emsp;ZYNQ，即Zynq-7000 All Programmable Soc (APSoC)，赛灵思公司(AMD Xilinx)推出的新一代全可编程片上系统。实际上，**ZYNQ = PS(Processing System，处理系统，ARM) + PL(Program Logic，可编程逻辑，实际上就是FPGA)**。两个系统可以独立使用，二者通过AXI高速接口进行数据通信。\n\n&emsp;&emsp;ZYNQ将处理器的软件可编程性与FPGA的硬件可编程性进行完美结合，以提供无与伦比的系统性能、灵活性和可扩展性。ZYNQ可以依靠片上的ARM内核运行Linux系统。\n\n&emsp;&emsp;ZYNQ是基于ARM处理器的SoC，可满足复杂嵌入式系统的高性能、低功耗和多核处理器等要求。SoC(System on Chip)和早期的SoB(System on Board)相对应。SoC的成本更低，能在不同的系统单元之间实现更快更安全的数据传输，具有更高的系统运行速度，更低的功耗，更小的物理尺寸和更高的可靠性。\n\n\n\n&emsp;&emsp;Soc主要可以分为以下三类：\n1. 基于ASIC的Soc；\n2. 可编程的片上系统(SOPC, System on Programmable Chip, 即FPGA)：灵活性很高，但是要实现这样的功能要使用的资源很多，导致最后实现的功能受限；\n3. 全可编程片上系统(APSoC, All Programmable SoC，即ZYNQ)。\n### 1.2 PL（FPGA）简介\n\n&emsp;&emsp;FPGA（Field Programmable Gate Array，现场可编程门阵列），一种可以通过编程来修改其逻辑功能的数字集成电路（芯片）。Xilinx公司对自己的最小可编程单元起名为可配置逻辑块CLB（Configurable Logic Block），一个CLB由两个片（Slice）组成，每个片中包含多个查找表LUT（Look Up Table）和触发器FF（Flip-Flop）。**PL部分就是7系列的FPGA部分，型号不同，资源不同，例如逻辑单元，内部存储器数量，乘法器，高速接口等。**\n\n&emsp;&emsp;FPGA的架构如下所示：\n- **可编程IO单元**：可将引脚配置为上拉或下拉、驱动电流、电平标准、输入、输出或双向等。\n- **可编程逻辑单元（CLB）**\n- **底层嵌入功能单元**：例如PLL、DSP、时钟管理等\n- **嵌入式块RAM（Block RAM）**：用来存储数据\n- **硬核**：例如XADC，不是每一个厂家的每一个芯片都有。XADC可以实现高速AD转换，检测片上温度和电压等。\n- **布线资源**\n- ...\n\n&emsp;&emsp;有以下两种PL架构，对应不同的ZYNQ型号\n- Artix-Based devices：Z-7010，Z-7015，Z-7020\n- Kintex-Based devices：Z-7030，Z-7045，Z-7100\n\n\n\n### 1.3 PS（处理系统）简介\n\nPS端集成了两个ARM Cortex-A9处理器，AMBA（Advanced Microcontroller Bus Architecture）互联，内部存储器，外部存储器接口和多种外设。外设主要包括USB总线接口，I2C总线接口，CAN总线接口，UART接口，GPIO，GigE，以太网接口，SD/SDIO接口等。\n\n在PS端有一部件称为APU（Application Processor Unit），可称为应用处理单元。内部除了两颗ARM核之外还有以下部件需要关注：\n\n- GIC（General Interrupt Controller）：通用中断控制器，用于接收来自外设的IRQ（Interrupt Request，中断请求）。\n- OCM（On Chip Memory）：片上存储单元，主要用于管理一块256K的SRAM。\n- Memory Interface：PS端内部有两个存储器接口，可以连接和管理芯片外部的存储器芯片，用于实现高速的数据存储、处理和传输。\n\n### 1.4 ZYNQ GPIO分布\n\n- MIO（Multiplexing IO）：存在于PS端，是可复用的IO。IO管脚的配置在一定程度上保留了灵活性以满足不同外设的需求。\n- EMIO（Extensible MIO）：存在于PL端，是对MIO的扩展。如果MIO不够用，这些端口可以直接从PL端扩展到PS端，被PS端直接使用。\n\nZYNQ有118个GPIO，分为54个MIO和64个EMIO。其中有32个MIO（Bank 0），22个MIO（Bank 1），32个EMIO（Bank 2），32个EMIO（Bank 3）。在概念的分组上，PS端有Bank 0和Bank 1两个分组，PL端有Bank 2和Bank 3两个分组。需要注意这些分组都是概念上的，在硬件上的分组有其他的形式。在硬件上，Bank 500、Bank 501、Bank 502是PS端的分组，Bank 13、Bank 33、Bank 34、Bank 35是PL端的分组。\n\n## 二、AXI 总线\n\n### 2.1 概述\n\nAXI（Advanced eXtensible Interface）是一种总线协议，该协议是 ARM 公司提出的 AMBA（Advanced Microcontroller Bus Architecture）3.0 协议中最重要的部分，是一种面向高性能、高带宽、低延迟的片内总线。**它的地址/控制和数据相位是分离的**，支持不对齐的数据传输，同时在突发传输中，只需要首地址，同时分离的读写数据通道、并支持显著传输访问和乱序访问，并更加容易就行时序收敛。AXI 是 AMBA 中一个新的高性能协议。AXI 技术丰富了现有的 AMBA 标准内容，满足超高性能和复杂的片上系统（SoC）设计的需求。\n\n**AXI 总线是连通 PS 和 PL 的一个总线协议，最终的形式就相当于 PL 块作为一个 IP Core 挂载在 AXI 总线上，然后由 PS 调用**。Xilinx 从 6 系列的 FPGA 开始对 AXI 总线提供支持，目前使用 AXI4 版本（在A7系列芯片中就可以找到AXI4总线协议）。\n\n### 2.2 AXI 总线协议种类\n\n\n\n- AXI4（For high-performance memory-mapped requirements）：主要面向高性能**地址映射**通信的需求，是面向地址映射的接口，允许最大256轮的数据突发传输；\n- AXI4-Lite（For Simple, low-throughput memory-mapped communication）：是一个轻量级的地址映射单次传输接口，占用的逻辑资源较少；\n- AXI4-Stream（For high-speed streaming data）：面向高速数据流传输，去掉了地址传输，允许无限制的数据突发传输规模。\n\n\n\n### 2.3 AXI 总线协议接口\n\n![image-20240321213944787](image-20240321213944787.png)\n\n- AXI-GP（General-Purpose，4个通道）：通用AXI接口，包括两个32位主设备接口（用于发送）和两个32位从设备接口（用于接收），通过该接口可以访问PS的片内外设；\n- AXI-HP（High-Performance，4个通道）：高性能/带宽的标准的接口，PL模块作为主设备连接，**主要用于PL访问PS上的存储器接口**，可以访问芯片外部的DDR芯片或片上的OCM（SRAM）；\n- AXI-ACP（Accelerator Consistency Port，1个通道）：加速器一致性端口，ARM多核架构下的一种接口，用来管理DMA之类的不带缓存的AXI外设，PS（APU）作从设备用于接收来自PL的数据。\n\n![image-20240321220104190](image-20240321220104190.png)","tags":["FPGA","ZYNQ"]},{"title":"Hexo 操作记录","url":"/2024/02/08/img-delete/","content":"## 添加文章\n\n&emsp;&emsp;创建文章时务必使用`hexo new new_blog`命令创建，以在`_posts`文件夹中生成与文章同名的文件夹。`new_blog`不能是中文名称。\n\n## 添加图片到文章中\n\n&emsp;&emsp;将图片复制到与文章的Markdown文件同名的文件夹下后，直接使用格式`![Img Description](Img.png)`在文章中添加图片。注意：==图片名称、路径以及图片描述都不能带中文，否则会遇到图片无法正常显示的问题。==\n\n## 删除文章\n\n1. 删除`_posts`下的所有与文章有关的文件\n2. 删除`.deploy_git`文件夹\n3. 执行`hexo clean`命令\n4. 执行`hexo g`命令\n5. 执行`hexo d`命令\n"},{"title":"基于FPGA设计的矿洞辅助工作芯片","url":"/2024/02/08/chip-designer/","content":"## 一、应用背景\n\n矿产资源勘探一直是一个国家重要的经济支柱，矿洞和矿场也是很多工人重要的工作场地。但是，与矿产相关的工作环境普遍存在极高的危险性，需要矿工拥有较强的安全防护意识。尽管如此，矿洞、矿场事故仍频频发生。为了提高矿工工作环境的安全度，我们设计了这款基于FPGA设计的矿洞辅助工作芯片，在芯片外部添加特定的模块电路，即可实现不同的功能，为矿工的工作提供辅助，对现场工作环境的安全性进行实时检测和预警。\n\n## 二、机器人功能设计\n\n机器人采取**小车+机械臂**为结构主体，在上面添加不同功能的模块扩展相应功能。\n\n1. 通过**视觉模块**和**机械臂模块**结合实现工具的抓取和归位。\n2. 通过**温湿度传感器模块**实时检测当前工作环境的温湿度，超过阈值则通过**蜂鸣器（音响）**进行预警。\n3. 通过**火焰传感器**和**烟雾传感器**结合检测当前工作环境附近是否存在矿产资源的自燃现象，如果有则通过**蜂鸣器（音响）**进行报警。\n4. 通过**光亮度传感器**实时检测当前工作环境亮度，当亮度低于阈值时自动开启灯光进行辅助照明。\n5. 通过**CO气敏传感器（MQ-7）**实时检测当前工作环境的CO浓度含量，如果超过阈值则通过**蜂鸣器（音响）**报警。\n6. 通过**超声波传感器**进行避障。\n7. 通过**蓝牙模块**和**语言控制模块**实现一定的人机交互，例如用手机APP连接蓝牙控制小车移动，控制小车机械臂，通过语言控制模块控制照明灯开关等。\n8. 通过**人体传感器（雷达跟踪）**检测附近工人位置，进行实时跟随。\n\n## 三、芯片模块设计\n\n\n![models](models.png)\n","tags":["FPGA","集创赛"]},{"title":"蓝桥杯比赛","url":"/2024/02/07/BlueBridge/","content":"# 蓝桥杯比赛\n\n## 竞赛提供文件\n\n1. USB驱动程序（一般不会用到）\n\n2. 底层驱动代码参考\n\n   - DS18B20温度传感器，一般省赛不会用，该配件在扩展版上\n\n   - I2C驱动程序（重要）\n\n3. 芯片资料：板子上几乎所有芯片的手册，大多数用不到，重要的在于STM32的编程手册和参考手册。客观题中相关问题可以直接查阅手册。\n\n4. 库文件（STM32CubeMX配置完成之后该文件也一般不会用到）\n\n5. 液晶驱动参考程序（重点）\n\n   开始比赛后直接将HAL_06_LCD直接复制一份作为工程模板使用，不用再写额外的LCD调试程序（其CubeMX工程版本可能有问题，**需要事先注意版本移植的问题**）。\n\n6. CT117E_M4_SCH.pdf：开发板原理图\n\n7. CT117E_M4产品手册：开发板开发手册，包含原理图\n\n##  客观题部分\n\n客观题包含：STM32相关、数电模电部分知识。主要看平时的积累，STM32相关不会的要会查阅手册。\n\n## 程序设计部分\n\n### 1 LED模块\n\n1. 修改CubeMX配置：IO引脚，IO端口\n2. 注意事项：使用LED时必须将`LE`引脚拉高，不用时拉低\n3. 使用说明：高电平LED熄灭，低电平LED点亮\n\n### 2 按键KEY模块\n\n1. 修改CubeMX配置：IO引脚，IO端口\n\n2. 注意事项：未按下为高电平，按下为低电平\n\n3. 按键需要消抖，但是不能阻塞程序，可以参考以下的扫描方式\n\n   ```c Key Scan Code\n   uint8_t KeyScanCount = 0;\n   uint8_t KeyScanFlag = 0;\n   uint8_t KeyPressedFlag = 0;\n   uint8_t KeyFlag = 0;\n   \n   /* 按键扫描函数，20ms扫描一次实现消抖 */\n   void Key_Scan(void)\n   {\n       for (uint8_t i = 0; i < 4; i ++)\n       {\n           if (HAL_GPIO_ReadPin(KeyPort[i], KeyPin[i]) == GPIO_PIN_SET)    // lift up\n           {\n           \tKeyPressedFlag &= ~(1 << i);   \n           }\n           else if ((KeyPressedFlag & (1 << i)) == 0)      // first push\n           {\n               if (HAL_GPIO_ReadPin(KeyPort[i], KeyPin[i]) == GPIO_PIN_SET)\n               {\n                   return;\n               }\n               KeyFlag |= (1 << i);\n               KeyPressedFlag |= (1 << i);\n           }\n       }\n   }\n   \n   void Key_Process(void)\n   {\n       printf(\"keyFlag: %X\\n\", KeyFlag);\n   }\n   ```\n\n   \n\n### 3 串口收发模块\n\n1. CubeMX配置USART1初始化；\n\n2. CubeMX使能USART中断；\n\n3. 串口发送：重写`fputc()`函数（**赛前多写几次**），即可直接使用`printf()`函数进行串口发送；\n\n   ```c\n   int fputc(int ch, FILE* f)\n   {\n   \tHAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFF);\n       return ch;\n   }\n   ```\n\n4. 串口接收：使能中断接收，之后重写中断服务函数`HAL_UART_RxCpltCallback()`函数即可：\n\n   ```C\n   HAL_UART_Receive_IT(&huart1, uartRxBuffer, 1);\n   ```\n\n   ```c\n   void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n   {\n       /* 接收处理代码 */\n   }\n   ```\n\n   \n\n### 4 ADC模块\n\n1. 初始化：直接在CubeMX中配置即可，推荐使用DMA循环模式触发ADC采样\n\n2. 开始采样：在程序初始化中直接开启DMA模式ADC采样。之后CPU就不用处理ADC的内容了，需要数据直接读取即可。\n\n   ```c\n   uint16_t AdcBuffer[2] = {0};\n   \n   HAL_ADC_Start_DMA(&hadc2, (uint32_t*)Adcbuffer, 2);\n   ```\n\n3. 读取数据：直接读取即可，DMA会自动更新其中的内容。\n\n   ```c\n   AdcDisplay[0] = Adcbuffer[0] * 3.3 / 4095.0;\n   AdcDisplay[1] = Adcbuffer[1] * 3.3 / 4095.0;\n   ```\n\n4. 数据不稳定：延长采样时间\n\n### 5 PWM输出\n\n1. 初始化：直接在CubeMX中配置好TIM与对应通道的PWM输出![PWM Config](PWM.png)\n\n2. 开始/停止：直接调用库函数即可\n\n   ```c\n   HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);\n   ```\n\n3. 调节频率设置占空比：直接设置PSC（预分频系数，一般不用设置这个）、ARR（自动重装载值）、CCRx（捕获比较寄存器）的值即可：\n\n   ```c\n   htim3.Instance->ARR = 49;\n   htim3.Instance->CCR2 = 99;\n   ```\n\n   \n\n### 6 测量PWM频率和占空比\n\n使用定时器的捕获中断服务回调函数处理。\n\n```c\nuint8_t pwmMode = 0;\nuint32_t pwmPosTime = 0;\ndouble pwmPredTime = 0;\ndouble pwmDuty = 0;\ndouble pwmFreq = 0;\n\nvoid HAL_TIM_IC_CaptureCallBack(TIM_HandleTypeDef *htim)\n{\n    if (pwmMode == 0)\n    {\n        htim2.Instance->CCER |= 0x0002;     // set rising detection to falling detection\n        htim2.Instance->CNT = 0;\n        pwmMode = 1;\n    }\n    else if (pwmMode == 1)\n    {\n        htim2.Instance->CCER &= ~0x0002;    // set falling detection to rising detection\n        pwmPosTime = htim2.Instance->CCR1;\n        pwmMode = 2;\n    }\n    else if (pwmMode == 2)\n    {\n        htim2.Instance->CCER |= 0x0002;     // set rising detection to falling detection\n        pwmPredTime = htim2.Instance->CCR1;\n        htim2.Instance->CNT = 0;\n        pwmMode = 1;\n        pwmDuty = (100.0 * pwmPosTime) / (pwmPredTime);\n        pwmFreq = 10000000.0 / (pwmPredTime);\t\t// 1000000.0 = 主频/PSC\n    }\n}\n```\n\n1. 第一次先捕获上升沿，清空计数器，并将两个时间设置为0；\n2. 第二次捕获下降沿，记录高电平时间；\n3. 第三次再捕获上升沿，记录整个周期的时间；\n4. 主函数中判断是否已经捕获完成一个周期，将pwmMode设置为0开始下一次捕获；\n\n## 整体代码编写思路\n\n题目的主要特点：\n\n1. 任务要求多\n2. 实时处理和显示\n3. 同一任务的处理时间间隔有一定要求\n\n从`HAL_06_LCD`工程开始逐步添加功能。最重要的编写思想是==前后台系统==。\n\n### 前后台系统\n\n前后台系统即将每一个模块及其相应称为一个任务。使用SysTick计时，每隔一段时间执行一次某个任务，同时该任务不能占据太长时间。以下面的代码为例：\n\n```c\nvoid SysTick_Handler(void)\n{\n    /* USER CODE BEGIN SysTick_IRQn 0 */\n\n    /* USER CODE END SysTick_IRQn 0 */\n    HAL_IncTick();\n    /* USER CODE BEGIN SysTick_IRQn 1 */\n\n    if (KeyScanCount == 49)         // 任务 1：按键扫描，50ms一次\n    {\n        KeyScanCount = 0;\n        KeyScanFlag = 1;\n    }\n    else \n    {\n        KeyScanCount ++;\n    }\n    \n    if (LEDRefreshCount == 99)         // 任务 2：LED刷新，100ms一次\n    {\n        LEDRefreshCount = 0;\n        LEDRefreshFlag = 1;\n    }\n    else \n    {\n        LEDRefreshCount ++;\n    }\n    \n    if (LCDRefreshCount == 99)         // 任务 3：LCD刷新，100y\n    {\n        LCDRefreshCount = 0;\n        LCDRefreshFlag = 1;\n    }\n    else \n    {\n        LCDRefreshCount ++;\n    }\n\n    /* USER CODE END SysTick_IRQn 1 */\n}\n```\n\n在`main`函数中：\n\n```c\nvoid main(void)\n{\n    /* Init code */\n\n    while (1)\n    {\n        if (LCDRefreshFlag == 1) {      // LCD刷新\n            LCD_Refresh();\n            LCDRefreshFlag = 0;\n        }\n        if (LEDRefreshFlag == 1) {      // LED刷新\n            LED_Refresh();\n            LEDRefreshFlag = 0;\n        }\n        if (KeyScanFlag == 1) {         // 按键扫描\n            Key_Scan();\n            KeyScanFlag = 0;\n        }\n        if (KeyFlag || KeyLongFlag) {   // 长按检测\n            Key_Process();\n            KeyFlag = 0;\n            KeyLongFlag = 0;\n        }\n    }\n}\n```\n\n","tags":["嵌入式开发","STM32","蓝桥杯"]},{"title":"about","url":"/about/index.html"},{"title":"friends","url":"/friends/index.html","content":"\n目前没有任何友链."},{"url":"/categories/index.html"},{"title":"projects","url":"/projects/index.html"},{"url":"/search/index.html"},{"url":"/tags/index.html"}]