[{"title":"Hexo 操作记录","url":"/2024/02/08/img-delete/","content":"## 添加文章\n\n&emsp;&emsp;创建文章时务必使用`hexo new new_blog`命令创建，以在`_posts`文件夹中生成与文章同名的文件夹。`new_blog`不能是中文名称。\n\n## 添加图片到文章中\n\n&emsp;&emsp;将图片复制到与文章的Markdown文件同名的文件夹下后，直接使用格式`![Img Description](Img.png)`在文章中添加图片。注意：==图片名称、路径以及图片描述都不能带中文，否则会遇到图片无法正常显示的问题。==\n\n## 删除文章\n\n1. 删除`_posts`下的所有与文章有关的文件\n2. 删除`.deploy_git`文件夹\n3. 执行`hexo clean`命令\n4. 执行`hexo g`命令\n5. 执行`hexo d`命令\n"},{"title":"基于FPGA设计的矿洞辅助工作芯片","url":"/2024/02/08/chip-designer/","content":"## 一、应用背景\n\n矿产资源勘探一直是一个国家重要的经济支柱，矿洞和矿场也是很多工人重要的工作场地。但是，与矿产相关的工作环境普遍存在极高的危险性，需要矿工拥有较强的安全防护意识。尽管如此，矿洞、矿场事故仍频频发生。为了提高矿工工作环境的安全度，我们设计了这款基于FPGA设计的矿洞辅助工作芯片，在芯片外部添加特定的模块电路，即可实现不同的功能，为矿工的工作提供辅助，对现场工作环境的安全性进行实时检测和预警。\n\n## 二、机器人功能设计\n\n机器人采取**小车+机械臂**为结构主体，在上面添加不同功能的模块扩展相应功能。\n\n1. 通过**视觉模块**和**机械臂模块**结合实现工具的抓取和归位。\n2. 通过**温湿度传感器模块**实时检测当前工作环境的温湿度，超过阈值则通过**蜂鸣器（音响）**进行预警。\n3. 通过**火焰传感器**和**烟雾传感器**结合检测当前工作环境附近是否存在矿产资源的自燃现象，如果有则通过**蜂鸣器（音响）**进行报警。\n4. 通过**光亮度传感器**实时检测当前工作环境亮度，当亮度低于阈值时自动开启灯光进行辅助照明。\n5. 通过**CO气敏传感器（MQ-7）**实时检测当前工作环境的CO浓度含量，如果超过阈值则通过**蜂鸣器（音响）**报警。\n6. 通过**超声波传感器**进行避障。\n7. 通过**蓝牙模块**和**语言控制模块**实现一定的人机交互，例如用手机APP连接蓝牙控制小车移动，控制小车机械臂，通过语言控制模块控制照明灯开关等。\n8. 通过**人体传感器（雷达跟踪）**检测附近工人位置，进行实时跟随。\n\n## 三、芯片模块设计\n\n\n![models](models.png)\n","tags":["集创赛","FPGA"]},{"title":"蓝桥杯比赛","url":"/2024/02/07/BlueBridge/","content":"# 蓝桥杯比赛\n\n## 竞赛提供文件\n\n1. USB驱动程序（一般不会用到）\n\n2. 底层驱动代码参考\n\n   - DS18B20温度传感器，一般省赛不会用，该配件在扩展版上\n\n   - I2C驱动程序（重要）\n\n3. 芯片资料：板子上几乎所有芯片的手册，大多数用不到，重要的在于STM32的编程手册和参考手册。客观题中相关问题可以直接查阅手册。\n\n4. 库文件（STM32CubeMX配置完成之后该文件也一般不会用到）\n\n5. 液晶驱动参考程序（重点）\n\n   开始比赛后直接将HAL_06_LCD直接复制一份作为工程模板使用，不用再写额外的LCD调试程序（其CubeMX工程版本可能有问题，**需要事先注意版本移植的问题**）。\n\n6. CT117E_M4_SCH.pdf：开发板原理图\n\n7. CT117E_M4产品手册：开发板开发手册，包含原理图\n\n##  客观题部分\n\n客观题包含：STM32相关、数电模电部分知识。主要看平时的积累，STM32相关不会的要会查阅手册。\n\n## 程序设计部分\n\n### 1 LED模块\n\n1. 修改CubeMX配置：IO引脚，IO端口\n2. 注意事项：使用LED时必须将`LE`引脚拉高，不用时拉低\n3. 使用说明：高电平LED熄灭，低电平LED点亮\n\n### 2 按键KEY模块\n\n1. 修改CubeMX配置：IO引脚，IO端口\n\n2. 注意事项：未按下为高电平，按下为低电平\n\n3. 按键需要消抖，但是不能阻塞程序，可以参考以下的扫描方式\n\n   ```c\n   uint8_t KeyScanCount = 0;\n   uint8_t KeyScanFlag = 0;\n   uint8_t KeyPressedFlag = 0;\n   uint8_t KeyFlag = 0;\n   \n   /* 按键扫描函数，20ms扫描一次实现消抖 */\n   void Key_Scan(void)\n   {\n       for (uint8_t i = 0; i < 4; i ++)\n       {\n           if (HAL_GPIO_ReadPin(KeyPort[i], KeyPin[i]) == GPIO_PIN_SET)    // lift up\n           {\n           \tKeyPressedFlag &= ~(1 << i);   \n           }\n           else if ((KeyPressedFlag & (1 << i)) == 0)      // first push\n           {\n               if (HAL_GPIO_ReadPin(KeyPort[i], KeyPin[i]) == GPIO_PIN_SET)\n               {\n                   return;\n               }\n               KeyFlag |= (1 << i);\n               KeyPressedFlag |= (1 << i);\n           }\n       }\n   }\n   \n   void Key_Process(void)\n   {\n       printf(\"keyFlag: %X\\n\", KeyFlag);\n   }\n   ```\n\n   \n\n### 3 串口收发模块\n\n1. CubeMX配置USART1初始化；\n\n2. CubeMX使能USART中断；\n\n3. 串口发送：重写`fputc()`函数（**赛前多写几次**），即可直接使用`printf()`函数进行串口发送；\n\n   ```c\n   int fputc(int ch, FILE* f)\n   {\n   \tHAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFF);\n       return ch;\n   }\n   ```\n\n4. 串口接收：使能中断接收，之后重写中断服务函数`HAL_UART_RxCpltCallback()`函数即可：\n\n   ```C\n   HAL_UART_Receive_IT(&huart1, uartRxBuffer, 1);\n   ```\n\n   ```c\n   void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n   {\n       /* 接收处理代码 */\n   }\n   ```\n\n   \n\n### 4 ADC模块\n\n1. 初始化：直接在CubeMX中配置即可，推荐使用DMA循环模式触发ADC采样\n\n2. 开始采样：在程序初始化中直接开启DMA模式ADC采样。之后CPU就不用处理ADC的内容了，需要数据直接读取即可。\n\n   ```c\n   uint16_t AdcBuffer[2] = {0};\n   \n   HAL_ADC_Start_DMA(&hadc2, (uint32_t*)Adcbuffer, 2);\n   ```\n\n3. 读取数据：直接读取即可，DMA会自动更新其中的内容。\n\n   ```c\n   AdcDisplay[0] = Adcbuffer[0] * 3.3 / 4095.0;\n   AdcDisplay[1] = Adcbuffer[1] * 3.3 / 4095.0;\n   ```\n\n4. 数据不稳定：延长采样时间\n\n### 5 PWM输出\n\n1. 初始化：直接在CubeMX中配置好TIM与对应通道的PWM输出![PWM Config](PWM.png)\n\n2. 开始/停止：直接调用库函数即可\n\n   ```c\n   HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);\n   ```\n\n3. 调节频率设置占空比：直接设置PSC（预分频系数，一般不用设置这个）、ARR（自动重装载值）、CCRx（捕获比较寄存器）的值即可：\n\n   ```c\n   htim3.Instance->ARR = 49;\n   htim3.Instance->CCR2 = 99;\n   ```\n\n   \n\n### 6 测量PWM频率和占空比\n\n使用定时器的捕获中断服务回调函数处理。\n\n```c\nuint8_t pwmMode = 0;\nuint32_t pwmPosTime = 0;\ndouble pwmPredTime = 0;\ndouble pwmDuty = 0;\ndouble pwmFreq = 0;\n\nvoid HAL_TIM_IC_CaptureCallBack(TIM_HandleTypeDef *htim)\n{\n    if (pwmMode == 0)\n    {\n        htim2.Instance->CCER |= 0x0002;     // set rising detection to falling detection\n        htim2.Instance->CNT = 0;\n        pwmMode = 1;\n    }\n    else if (pwmMode == 1)\n    {\n        htim2.Instance->CCER &= ~0x0002;    // set falling detection to rising detection\n        pwmPosTime = htim2.Instance->CCR1;\n        pwmMode = 2;\n    }\n    else if (pwmMode == 2)\n    {\n        htim2.Instance->CCER |= 0x0002;     // set rising detection to falling detection\n        pwmPredTime = htim2.Instance->CCR1;\n        htim2.Instance->CNT = 0;\n        pwmMode = 1;\n        pwmDuty = (100.0 * pwmPosTime) / (pwmPredTime);\n        pwmFreq = 10000000.0 / (pwmPredTime);\t\t// 1000000.0 = 主频/PSC\n    }\n}\n```\n\n1. 第一次先捕获上升沿，清空计数器，并将两个时间设置为0；\n2. 第二次捕获下降沿，记录高电平时间；\n3. 第三次再捕获上升沿，记录整个周期的时间；\n4. 主函数中判断是否已经捕获完成一个周期，将pwmMode设置为0开始下一次捕获；\n\n## 整体代码编写思路\n\n题目的主要特点：\n\n1. 任务要求多\n2. 实时处理和显示\n3. 同一任务的处理时间间隔有一定要求\n\n从`HAL_06_LCD`工程开始逐步添加功能。最重要的编写思想是==前后台系统==。\n\n### 前后台系统\n\n前后台系统即将每一个模块及其相应称为一个任务。使用SysTick计时，每隔一段时间执行一次某个任务，同时该任务不能占据太长时间。以下面的代码为例：\n\n```c\nvoid SysTick_Handler(void)\n{\n    /* USER CODE BEGIN SysTick_IRQn 0 */\n\n    /* USER CODE END SysTick_IRQn 0 */\n    HAL_IncTick();\n    /* USER CODE BEGIN SysTick_IRQn 1 */\n\n    if (KeyScanCount == 49)         // 任务 1：按键扫描，50ms一次\n    {\n        KeyScanCount = 0;\n        KeyScanFlag = 1;\n    }\n    else \n    {\n        KeyScanCount ++;\n    }\n    \n    if (LEDRefreshCount == 99)         // 任务 2：LED刷新，100ms一次\n    {\n        LEDRefreshCount = 0;\n        LEDRefreshFlag = 1;\n    }\n    else \n    {\n        LEDRefreshCount ++;\n    }\n    \n    if (LCDRefreshCount == 99)         // 任务 3：LCD刷新，100y\n    {\n        LCDRefreshCount = 0;\n        LCDRefreshFlag = 1;\n    }\n    else \n    {\n        LCDRefreshCount ++;\n    }\n\n    /* USER CODE END SysTick_IRQn 1 */\n}\n```\n\n在`main`函数中：\n\n```c\nvoid main(void)\n{\n    /* Init code */\n\n    while (1)\n    {\n        if (LCDRefreshFlag == 1) {      // LCD刷新\n            LCD_Refresh();\n            LCDRefreshFlag = 0;\n        }\n        if (LEDRefreshFlag == 1) {      // LED刷新\n            LED_Refresh();\n            LEDRefreshFlag = 0;\n        }\n        if (KeyScanFlag == 1) {         // 按键扫描\n            Key_Scan();\n            KeyScanFlag = 0;\n        }\n        if (KeyFlag || KeyLongFlag) {   // 长按检测\n            Key_Process();\n            KeyFlag = 0;\n            KeyLongFlag = 0;\n        }\n    }\n}\n```\n\n","tags":["嵌入式开发","STM32","蓝桥杯"]},{"title":"about","url":"/about/index.html"},{"url":"/categories/index.html"},{"title":"projects","url":"/projects/index.html"},{"url":"/search/index.html"},{"title":"friends","url":"/friends/index.html"},{"url":"/tags/index.html"}]